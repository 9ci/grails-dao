{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nSince we were setting up a bunch of services that looked a lot like the old school Dao's. We figured we would just call them that instead of data services, repository, etc...\n\n\nPurpose\n\n\n\n\nTo provide standardization across our apps for transactional saves using failOnError:true to throw a Runtime Exception without changing config. see persist() method.\n\n\nensure that each call to persist() will create a Transaction if its not already inside of one. See more about the problems that can occur in example below.\n\n\nA clean standard way to abstract boiler plate business logic from the controller into a this dao service for databinding maps and JSON. Works somewhat like gorm's new data services. \n\n\neasily allows validation outside of constraints to persistence without needing to modify the domain source. For example, if I have a \nThing\n domain in my things plugin and I need to customize the validation logic for an insert in my Fancy-Thing app or perhaps implement events, I can simply create a ThingDao in the Fancy-Thing that overrides the one in the Thing plugin. \n\n\n\n\nProblems with doing more advanced persistence that you can in beforeInsert, beforeUpdate, etc with the build in GORM. As mentioned in the gorm docs\n\n\n\n\nDo not attempt to flush the session within an event (such as with obj.save(flush:true)). Since events are fired during flushing this will cause a StackOverflowError.\"\n\n\n\n\n\n\nwe ran into a number of problems, as many do, with session management here. A dao service creates simple centralized contract for how to do this without suffering from the session limitations in hibernate/gorm\n\n\n\n\n\n\n\n\nIf you are using envers or cascade saves then we want the saves and updates to be in a transaction by default and a proper thrown error to cause a roll back of all the changes. Not something you get with failOnError:false.\n\n\nExample of the transaction propagation issue:\n\n\nWith the cascade save of an association where we were saving a Parent with new Child. The issue will kick in when new Child saved and blew up and the Parent changes stay. We have a good example of this issue in the demo-app under test\n\n\nWith this plugin and a controller you can just do:\n\n\ndef\n \nupdate\n()\n \n{\n\n  \ntry\n{\n\n    \ndef\n \nresult\n \n=\n \nYourDomainClass\n.\nupdate\n(\np\n)\n\n      \nflash\n.\nmessage\n \n=\n \nresult\n.\nmessage\n\n      \nredirect\n(\naction:\n \nshow\n,\n \nid:\n \nresult\n.\nentity\n.\nid\n)\n\n  \n}\n \ncatch\n(\nDomainException\n \ne\n)\n \n{\n\n    \nflash\n.\nmessage\n \n=\n \ne\n.\nmessageMap\n\n    \nrender\n(\nview:\n \nedit\n,\n \nmodel:\n \n[(\ndomainInstanceName\n):\n \ne\n.\nentity\n])\n\n  \n}\n\n\n}\n\n\n\n\n\nEach domain gets injected with its own static dao object based on the GormDaoSupport service. If it finds a service that in the form of \nDao that is in any services or dao dir under grai-app then it will use that.\n\n\nExample\n You can setup your own dao for the domain like so and keep the logic in your Dao service and leave the controller alone as all the logic will flow over\n\n\nSee \nGormDaoSupport\n\n\nclass\n \nOrgDao\n \nextends\n \nGormDaoSupport\n \n{\n\n    \ndef\n \ndomainClass\n \n=\n \nOrg\n\n\n    \ndef\n \nupdate\n(\nparams\n){\n\n        \n// ... do some stuff to the params\n\n        \ndef\n \nresult\n \n=\n \nsuper\n.\nupdate\n(\nparams\n)\n\n        \n// ... do something like log history or send email with result.entity which is the saved org\n\n        \nreturn\n \nresult\n\n    \n}\n\n\n}\n\n\n\n\n\nInstallation\n\n\nGetting Started\n\n\nDomain Traits\n\n\nDynamic methods added to the domains\n\n\nEvery domain gets a dao which is either setup for you or setup by extending e \nGormDaoSupport\n. Each method is transactional to prevent incomplete cascading saves as exaplained above.\n\n\npersist()\n: calls the dao.save which in turn calls the dao.save(args) and then domain.save(failOnError:true) with any other args passed in. ex: someDomain.persist(). Throws a \nDomainException\n if anything goes wrong\n\n\nremove()\n:  calls the dao.delete which calls the dao.remove(args) which in turn calls the domain.delete(flush:true) by default. Throws a \nDomainException\n if anything goes wrong\n\n\nStatics added to the domain\n\n\ninsertAndSave(params)\n:  calls the dao.insert which does the bolier plate code you might find in a scaffolded controller. creates a new instance, sets the params and calls the dao.save (essentially the persist()). \nex:\n Book.insertAndSave([name:'xyz',isbn:'123']) Throws a \nDomainException\n if anything goes wrong\n\n\nupdate(params)\n:  calls the dao.update which does the boiler plate code you might find in a scaffolded controller. gets the instance base in the params.id, sets the params and calls the dao.save for it. \nex:\n Book.update([id:11,name:'aaa']) Throws a \nDomainException\n if anything goes wrong\n\n\nremove(params)\n:  calls the dao.delete gets the instance base in the params.id, calls the delete for it. \nex:\n Book.remove([id:11]) Throws a \nDomainException\n if anything goes wrong\n\n\ndao\n: a quick way to get to the dao for the Domain. It will return the stock dao that was created from GormDaoSupport or the Dao you created for the domain.\n\n\nDaoUtil and DaoMessage\n\n\nSee \nDaoUtil\n\n\nDaoUtil:\n\n\ncheckFound(entity, Map params,String domainClassName)\n checks does the entity exists, if not throws DomainNotFoundException with human readable error text\n\n\ncheckVersion(entity,ver)\n checks the passed in version with the version on the entity (entity.version) make sure entity.version is not greater, throws DomainException\n\n\nflush()\n flushes the session\n\n\nclear()\n clears session cache\n\n\nflushAndClear()\n flushes the session and clears the session cache\n\n\nDaoMessage contains bunch of help methods for creating text messages\n\n\nSee \nDaoMessage\n\n\nGrails 3:\n\n\nDynamic methods were implemented with trait instead of meta programing, so now \n@CompileStatic\n can be used.\nDue to this changes static method \ninsert\n for domain objects was renamed to \ninsertAndSave\n, because domain class instances\nalready have \ninsert\n method and we can't have both static and instance methods with same list of args.\n\n\nExample\n To be able to use advantages of the dao plugin for REST apps, extend controller from RestDaoController:\n\n\nSee \nRestDaoController\n\n\nclass\n \nOrgController\n \nextends\n \nRestDaoController\nOrg\n \n{\n\n    \nstatic\n \nresponseFormats\n \n=\n \n[\njson\n]\n\n    \nstatic\n \nnamespace\n \n=\n \napi\n\n\n    \nOrgController\n()\n \n{\n\n        \nsuper\n(\nOrg\n)\n\n    \n}\n\n\n}\n\n\n\n\n\nIf controller is extended for RestDaoController then methods will use dao services for current domain. For example\nPOST action will call dao insert method for Org domain.",
            "title": "Overview"
        },
        {
            "location": "/#introduction",
            "text": "Since we were setting up a bunch of services that looked a lot like the old school Dao's. We figured we would just call them that instead of data services, repository, etc...  Purpose   To provide standardization across our apps for transactional saves using failOnError:true to throw a Runtime Exception without changing config. see persist() method.  ensure that each call to persist() will create a Transaction if its not already inside of one. See more about the problems that can occur in example below.  A clean standard way to abstract boiler plate business logic from the controller into a this dao service for databinding maps and JSON. Works somewhat like gorm's new data services.   easily allows validation outside of constraints to persistence without needing to modify the domain source. For example, if I have a  Thing  domain in my things plugin and I need to customize the validation logic for an insert in my Fancy-Thing app or perhaps implement events, I can simply create a ThingDao in the Fancy-Thing that overrides the one in the Thing plugin.    Problems with doing more advanced persistence that you can in beforeInsert, beforeUpdate, etc with the build in GORM. As mentioned in the gorm docs   Do not attempt to flush the session within an event (such as with obj.save(flush:true)). Since events are fired during flushing this will cause a StackOverflowError.\"    we ran into a number of problems, as many do, with session management here. A dao service creates simple centralized contract for how to do this without suffering from the session limitations in hibernate/gorm     If you are using envers or cascade saves then we want the saves and updates to be in a transaction by default and a proper thrown error to cause a roll back of all the changes. Not something you get with failOnError:false.  Example of the transaction propagation issue:  With the cascade save of an association where we were saving a Parent with new Child. The issue will kick in when new Child saved and blew up and the Parent changes stay. We have a good example of this issue in the demo-app under test  With this plugin and a controller you can just do:  def   update ()   { \n   try { \n     def   result   =   YourDomainClass . update ( p ) \n       flash . message   =   result . message \n       redirect ( action:   show ,   id:   result . entity . id ) \n   }   catch ( DomainException   e )   { \n     flash . message   =   e . messageMap \n     render ( view:   edit ,   model:   [( domainInstanceName ):   e . entity ]) \n   }  }   Each domain gets injected with its own static dao object based on the GormDaoSupport service. If it finds a service that in the form of  Dao that is in any services or dao dir under grai-app then it will use that.  Example  You can setup your own dao for the domain like so and keep the logic in your Dao service and leave the controller alone as all the logic will flow over  See  GormDaoSupport  class   OrgDao   extends   GormDaoSupport   { \n     def   domainClass   =   Org \n\n     def   update ( params ){ \n         // ... do some stuff to the params \n         def   result   =   super . update ( params ) \n         // ... do something like log history or send email with result.entity which is the saved org \n         return   result \n     }  }",
            "title": "Introduction"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/#domain-traits",
            "text": "",
            "title": "Domain Traits"
        },
        {
            "location": "/#dynamic-methods-added-to-the-domains",
            "text": "Every domain gets a dao which is either setup for you or setup by extending e  GormDaoSupport . Each method is transactional to prevent incomplete cascading saves as exaplained above.  persist() : calls the dao.save which in turn calls the dao.save(args) and then domain.save(failOnError:true) with any other args passed in. ex: someDomain.persist(). Throws a  DomainException  if anything goes wrong  remove() :  calls the dao.delete which calls the dao.remove(args) which in turn calls the domain.delete(flush:true) by default. Throws a  DomainException  if anything goes wrong",
            "title": "Dynamic methods added to the domains"
        },
        {
            "location": "/#statics-added-to-the-domain",
            "text": "insertAndSave(params) :  calls the dao.insert which does the bolier plate code you might find in a scaffolded controller. creates a new instance, sets the params and calls the dao.save (essentially the persist()).  ex:  Book.insertAndSave([name:'xyz',isbn:'123']) Throws a  DomainException  if anything goes wrong  update(params) :  calls the dao.update which does the boiler plate code you might find in a scaffolded controller. gets the instance base in the params.id, sets the params and calls the dao.save for it.  ex:  Book.update([id:11,name:'aaa']) Throws a  DomainException  if anything goes wrong  remove(params) :  calls the dao.delete gets the instance base in the params.id, calls the delete for it.  ex:  Book.remove([id:11]) Throws a  DomainException  if anything goes wrong  dao : a quick way to get to the dao for the Domain. It will return the stock dao that was created from GormDaoSupport or the Dao you created for the domain.",
            "title": "Statics added to the domain"
        },
        {
            "location": "/#daoutil-and-daomessage",
            "text": "See  DaoUtil",
            "title": "DaoUtil and DaoMessage"
        },
        {
            "location": "/#daoutil",
            "text": "checkFound(entity, Map params,String domainClassName)  checks does the entity exists, if not throws DomainNotFoundException with human readable error text  checkVersion(entity,ver)  checks the passed in version with the version on the entity (entity.version) make sure entity.version is not greater, throws DomainException  flush()  flushes the session  clear()  clears session cache  flushAndClear()  flushes the session and clears the session cache",
            "title": "DaoUtil:"
        },
        {
            "location": "/#daomessage-contains-bunch-of-help-methods-for-creating-text-messages",
            "text": "See  DaoMessage",
            "title": "DaoMessage contains bunch of help methods for creating text messages"
        },
        {
            "location": "/#grails-3",
            "text": "Dynamic methods were implemented with trait instead of meta programing, so now  @CompileStatic  can be used.\nDue to this changes static method  insert  for domain objects was renamed to  insertAndSave , because domain class instances\nalready have  insert  method and we can't have both static and instance methods with same list of args.  Example  To be able to use advantages of the dao plugin for REST apps, extend controller from RestDaoController:  See  RestDaoController  class   OrgController   extends   RestDaoController Org   { \n     static   responseFormats   =   [ json ] \n     static   namespace   =   api \n\n     OrgController ()   { \n         super ( Org ) \n     }  }   If controller is extended for RestDaoController then methods will use dao services for current domain. For example\nPOST action will call dao insert method for Org domain.",
            "title": "Grails 3:"
        },
        {
            "location": "/id-generation/",
            "text": "Database ID Generator\n\n\nDao plugin comes with an implementation of hibernate identity generator which uses a central table for incremental identity generation.\n\n\nNewObjectId table\n\n\nIn order to use identity generator provided by plugin, you need to create NewObjectId table as shown below.\n\n\ncreate\n \ntable\n \nNewObjectId\n\n\n(\n\n    \nKeyName\n \nvarchar\n(\n255\n)\n \nnot\n \nnull\n \nprimary\n \nkey\n,\n\n    \nNextId\n \nbigint\n \nnot\n \nnull\n\n\n)\n\n\n;\n\n\n\n\n\nHere key name will be the name of the tables and NextId is the next id to return for the given table.\n\n\nConfigure Identity generator globally.\n\n\nThe identity generator can be configured globally in application.groovy as shown below.\n\n\ngrails\n \n{\n\n\n    \ngorm\n.\ndefault\n.\nmapping\n \n=\n \n{\n\n        \nid\n \ncolumn:\n \nid\n,\n \ngenerator:\ngorm.tools.idgen.SpringIdGenerator\n\n    \n}\n\n\n}\n\n\n\n\n\nThis will use the SpringIdGenerator for all domains in the application. However it can be done per domain too if required.\n\n\nUsing IdGenerator programmatically\n\n\nPlugin defines a bean with name idGenerator that can be used to programmatically generate new Ids.\nHere is an example domain class.\n\n\nclass\n \nBook\n \n{\n\n    \ntransient\n \nidGenerator\n\n\n    \ndef\n \nbeforeInsert\n()\n \n{\n\n        \nif\n(!\nid\n)\n \nid\n \n=\n \nidGenerator\n.\ngetNextId\n(\nBook.id\n)\n\n    \n}\n\n\n}\n\n\n\n\n\nIdentity generator will check in NewObjectId table for keyName \nBook\n If it exists, it will return the value of NextId or else it will insert a new row in NewObjectId table.",
            "title": "Id Generation"
        },
        {
            "location": "/id-generation/#database-id-generator",
            "text": "Dao plugin comes with an implementation of hibernate identity generator which uses a central table for incremental identity generation.",
            "title": "Database ID Generator"
        },
        {
            "location": "/id-generation/#newobjectid-table",
            "text": "In order to use identity generator provided by plugin, you need to create NewObjectId table as shown below.  create   table   NewObjectId  ( \n     KeyName   varchar ( 255 )   not   null   primary   key , \n     NextId   bigint   not   null  )  ;   Here key name will be the name of the tables and NextId is the next id to return for the given table.",
            "title": "NewObjectId table"
        },
        {
            "location": "/id-generation/#configure-identity-generator-globally",
            "text": "The identity generator can be configured globally in application.groovy as shown below.  grails   { \n\n     gorm . default . mapping   =   { \n         id   column:   id ,   generator: gorm.tools.idgen.SpringIdGenerator \n     }  }   This will use the SpringIdGenerator for all domains in the application. However it can be done per domain too if required.",
            "title": "Configure Identity generator globally."
        },
        {
            "location": "/id-generation/#using-idgenerator-programmatically",
            "text": "Plugin defines a bean with name idGenerator that can be used to programmatically generate new Ids.\nHere is an example domain class.  class   Book   { \n     transient   idGenerator \n\n     def   beforeInsert ()   { \n         if (! id )   id   =   idGenerator . getNextId ( Book.id ) \n     }  }   Identity generator will check in NewObjectId table for keyName  Book  If it exists, it will return the value of NextId or else it will insert a new row in NewObjectId table.",
            "title": "Using IdGenerator programmatically"
        },
        {
            "location": "/gorm-utils/",
            "text": "Gorm-tools provides two utils to work with domains.\nSee \nGormUtils\n\nand \nGormMetaUtils\n\n\nGormUtils\n\n\nCoping properties from source to target domain instance\n\n\nUsing \ncopyProperties\n we can copy some of properties from one domain to another:\n\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n)\n\n    \nUser\n \nuser2\n \n=\n \nnew\n \nUser\n()\n\n    \nUser\n \nuser3\n \n=\n \nnew\n \nUser\n()\n\n\n    \nGormUtils\n.\ncopyProperties\n(\nuser\n,\n \nuser2\n,\n \nfalse\n,\n \nfirstName\n)\n\n    \nGormUtils\n.\ncopyProperties\n(\nuser\n,\n \nuser3\n,\n \nfalse\n,\n \nfirstName\n,\n \nage\n)\n\n\n    \nassert\n \nuser2\n.\nfirstName\n \n==\n \nuser\n.\nfirstName\n\n    \nassert\n \nuser2\n.\nage\n \n!=\n \nuser\n.\nage\n\n\n    \nassert\n \nuser3\n.\nfirstName\n \n==\n \nuser\n.\nfirstName\n\n    \nassert\n \nuser3\n.\nage\n \n==\n \nuser\n.\nage\n\n\n\nIn this example \nuser\n is the source object, \nuser2\n and \nuser3\n are targets.\nIf the 3\nrd\n argument is false the method will override a target value even if it's not null.\nThen we can specify properties to copy from the source object.\n\n\nFetching a nested property using a string name\n\n\nGormUtils allows us to get a nested property from an object using a string as a path:\n\n\n    \nAddress\n \naddress\n \n=\n \nnew\n \nAddress\n(\nstreet:\n \nstreet\n,\n \ncity:\n \ncity\n)\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n,\n \naddress:\n \naddress\n)\n\n\n    \nString\n \nstreet\n \n=\n \nGormUtils\n.\ngetPropertyValue\n(\nperson\n,\n \naddress.street\n)\n\n\n    \nassert\n \nstreet\n \n==\n \naddress\n.\nstreet\n\n\n\nAs you can see we can specify nested properties simply by adding a ( \n.\n ) symbol to a parent's property name.\n\n\nCopying a domain instance\n\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n)\n\n\n    \nUser\n \ncopy\n \n=\n \nGormUtils\n.\ncopyDomain\n(\nUser\n,\n \nuser\n)\n\n    \nassert\n \ncopy\n.\nfirstName\n \n==\n \nJohn\n\n    \nassert\n \ncopy\n.\nlastName\n \n==\n \nDoe\n\n    \nassert\n \ncopy\n.\nage\n \n==\n \n30\n\n\n\nor with existing object\n\n\n    \nUser\n \ncopy\n \n=\n \nGormUtils\n.\ncopyDomain\n(\nnew\n \nUser\n(),\n \nuser\n)\n\n    \nassert\n \ncopy\n.\nfirstName\n \n==\n \nJohn\n\n    \nassert\n \ncopy\n.\nlastName\n \n==\n \nDoe\n\n    \nassert\n \ncopy\n.\nage\n \n==\n \n30\n\n\n\n\n\nGormMetaUtils\n\n\nGetting a domain class\n\n\n    \n// using a fully qualified name with package\n\n    \nGormMetaUtils\n.\ngetDomainClass\n(\ngorm.tools.Org\n)\n\n\n    \n// using a domain instance\n\n    \nGormMetaUtils\n.\ngetDomainClass\n(\nnew\n \nOrg\n())\n\n\n    \n// using a class\n\n    \nGormMetaUtils\n.\ngetDomainClass\n(\nOrg\n)\n\n\n\n\n\nGetting a persistent entity\n\n\n    \n// using a fully qualified name with package\n\n    \nGormMetaUtils\n.\ngetPersistentEntity\n(\ngorm.tools.Org\n)\n\n\n    \n// using a domain instance\n\n    \nGormMetaUtils\n.\ngetPersistentEntity\n(\nnew\n \nOrg\n())\n\n\n    \n// using a class\n\n    \nGormMetaUtils\n.\ngetPersistentEntity\n(\nOrg\n)",
            "title": "Gorm utils"
        },
        {
            "location": "/gorm-utils/#gormutils",
            "text": "",
            "title": "GormUtils"
        },
        {
            "location": "/gorm-utils/#coping-properties-from-source-to-target-domain-instance",
            "text": "Using  copyProperties  we can copy some of properties from one domain to another:       User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ) \n     User   user2   =   new   User () \n     User   user3   =   new   User () \n\n     GormUtils . copyProperties ( user ,   user2 ,   false ,   firstName ) \n     GormUtils . copyProperties ( user ,   user3 ,   false ,   firstName ,   age ) \n\n     assert   user2 . firstName   ==   user . firstName \n     assert   user2 . age   !=   user . age \n\n     assert   user3 . firstName   ==   user . firstName \n     assert   user3 . age   ==   user . age  \nIn this example  user  is the source object,  user2  and  user3  are targets.\nIf the 3 rd  argument is false the method will override a target value even if it's not null.\nThen we can specify properties to copy from the source object.",
            "title": "Coping properties from source to target domain instance"
        },
        {
            "location": "/gorm-utils/#fetching-a-nested-property-using-a-string-name",
            "text": "GormUtils allows us to get a nested property from an object using a string as a path:       Address   address   =   new   Address ( street:   street ,   city:   city ) \n     User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ,   address:   address ) \n\n     String   street   =   GormUtils . getPropertyValue ( person ,   address.street ) \n\n     assert   street   ==   address . street  \nAs you can see we can specify nested properties simply by adding a (  .  ) symbol to a parent's property name.",
            "title": "Fetching a nested property using a string name"
        },
        {
            "location": "/gorm-utils/#copying-a-domain-instance",
            "text": "User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ) \n\n     User   copy   =   GormUtils . copyDomain ( User ,   user ) \n     assert   copy . firstName   ==   John \n     assert   copy . lastName   ==   Doe \n     assert   copy . age   ==   30  \nor with existing object       User   copy   =   GormUtils . copyDomain ( new   User (),   user ) \n     assert   copy . firstName   ==   John \n     assert   copy . lastName   ==   Doe \n     assert   copy . age   ==   30",
            "title": "Copying a domain instance"
        },
        {
            "location": "/gorm-utils/#gormmetautils",
            "text": "",
            "title": "GormMetaUtils"
        },
        {
            "location": "/gorm-utils/#getting-a-domain-class",
            "text": "// using a fully qualified name with package \n     GormMetaUtils . getDomainClass ( gorm.tools.Org ) \n\n     // using a domain instance \n     GormMetaUtils . getDomainClass ( new   Org ()) \n\n     // using a class \n     GormMetaUtils . getDomainClass ( Org )",
            "title": "Getting a domain class"
        },
        {
            "location": "/gorm-utils/#getting-a-persistent-entity",
            "text": "// using a fully qualified name with package \n     GormMetaUtils . getPersistentEntity ( gorm.tools.Org ) \n\n     // using a domain instance \n     GormMetaUtils . getPersistentEntity ( new   Org ()) \n\n     // using a class \n     GormMetaUtils . getPersistentEntity ( Org )",
            "title": "Getting a persistent entity"
        },
        {
            "location": "/beanPathTools/",
            "text": "Gorm-tools comes with BeanPathTools util which provides a convenient way for manipulating with object's properties.\nSee \nBeanPathTools\n\n\nGetting specified object's properties to a map\n\n\nIn order to retrieve properties from an object and place them to a map we can use \nbuildMapFromPaths\n\nWe can possible to specify fields which should be added to the resulting map\nby providing a list with property names as the second argument.\n\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n)\n\n\n    \nMap\n \nuserName\n \n=\n \nBeanPathTools\n.\nbuildMapFromPaths\n(\nuser\n,\n \n[\nfirstName\n,\n \nlastName\n])\n\n    \nassert\n \nuserName\n \n==\n \n[\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n]\n\n\n\n\n\nGetting nested properties:\n\n\nIt is also works well with nested properties. To get a nested property we need to specify\na full path including parent field names divided with the ( \n.\n ) sign. See example below:\n\n\n    \nAddress\n \naddress\n \n=\n \nnew\n \nAddress\n(\nstreet1:\n \nstreet1\n,\n \nstreet2:\n \nstreet2\n \nzip:\n \n123456\n,\n \ncity:\n \ncity\n)\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n,\n \naddress:\n \naddress\n)\n\n\n    \nMap\n \nstreet\n \n=\n \nBeanPathTools\n.\nbuildMapFromPaths\n(\nuser\n,\n \n[\naddress.street1\n,\n \naddress.street2\n])\n\n    \nassert\n \nstreet\n \n==\n \n[\naddress:\n \n[\nstreet1:\n \nstreet1\n,\n \nstreet2:\n \nstreet2\n]]\n\n\n    \nMap\n \nfullAddress\n \n=\n \nBeanPathTools\n.\nbuildMapFromPaths\n(\nuser\n,\n \n[\naddress.*\n])\n\n    \nassert\n \nfullAddress\n \n==\n \n[\naddress:\n \n[\nstreet1:\n \nstreet1\n,\n \nstreet2:\n \nstreet2\n \nzip:\n \n123456\n,\n \ncity:\n \ncity\n]]\n\n\n\n\n\nGetting all object's properties to a map\n\n\n\n\nNOTE: in case of a domain instance the method looks only for persistent properties\n\n\n\n\nThe ( \n*\n )  sign represents all properties. Thus in order to get all fields we can use it as shown below:\n\n\n    \nMap\n \nuserMap\n \n=\n \nBeanPathTools\n.\nbuildMapFromPaths\n(\nuser\n,\n \n[\n*\n])\n\n    \nassert\n \nuserMap\n \n==\n \n[\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n]",
            "title": "Working with object's fields"
        },
        {
            "location": "/beanPathTools/#getting-specified-objects-properties-to-a-map",
            "text": "In order to retrieve properties from an object and place them to a map we can use  buildMapFromPaths \nWe can possible to specify fields which should be added to the resulting map\nby providing a list with property names as the second argument.       User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ) \n\n     Map   userName   =   BeanPathTools . buildMapFromPaths ( user ,   [ firstName ,   lastName ]) \n     assert   userName   ==   [ firstName:   John ,   lastName:   Doe ]",
            "title": "Getting specified object's properties to a map"
        },
        {
            "location": "/beanPathTools/#getting-nested-properties",
            "text": "It is also works well with nested properties. To get a nested property we need to specify\na full path including parent field names divided with the (  .  ) sign. See example below:       Address   address   =   new   Address ( street1:   street1 ,   street2:   street2   zip:   123456 ,   city:   city ) \n     User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ,   address:   address ) \n\n     Map   street   =   BeanPathTools . buildMapFromPaths ( user ,   [ address.street1 ,   address.street2 ]) \n     assert   street   ==   [ address:   [ street1:   street1 ,   street2:   street2 ]] \n\n     Map   fullAddress   =   BeanPathTools . buildMapFromPaths ( user ,   [ address.* ]) \n     assert   fullAddress   ==   [ address:   [ street1:   street1 ,   street2:   street2   zip:   123456 ,   city:   city ]]",
            "title": "Getting nested properties:"
        },
        {
            "location": "/beanPathTools/#getting-all-objects-properties-to-a-map",
            "text": "NOTE: in case of a domain instance the method looks only for persistent properties   The (  *  )  sign represents all properties. Thus in order to get all fields we can use it as shown below:       Map   userMap   =   BeanPathTools . buildMapFromPaths ( user ,   [ * ]) \n     assert   userMap   ==   [ firstName:   John ,   lastName:   Doe   age:   30 ]",
            "title": "Getting all object's properties to a map"
        },
        {
            "location": "/working-with-queries/",
            "text": "Gorm-tools provides a convenient way for iterating over records which correspond to a given SQL query.\n\n\nScrollableQuery\n\n\nSee \nScrollableQuery\n\n\nExecute a closure for each record\n\n\nAs you can see in the example below, we can specify the SQL query and provide the closure which is called for each record:\n\n\n    \nScrollableQuery\n \nscrollableQuery\n \n=\n \nnew\n \nScrollableQuery\n(\nnew\n \nColumnMapRowMapper\n(),\n \ndataSource\n,\n \n50\n)\n\n\n    \nscrollableQuery\n.\neachRow\n(\nselect * from ScrollableQueryTest\n)\n \n{\n \nObject\n \nrow\n \n-\n\n        \nprintln\n \nrow\n\n    \n}\n\n\n\n\n\nExecute a closure for each batch of records\n\n\nUsing \neachBatch\n we can execute a closure for a batch of records.\nThis closure is called for a specified number of records. For example, code below prints size of each batch\n(which is 5) to console:\n\n\n    \nscrollableQuery\n.\neachBatch\n(\nselect * from ScrollableQueryTest\n,\n \n5\n)\n \n{\n \nList\n \nbatch\n \n-\n\n        \nprintln\n \nbatchSize=${batch.size()}\n\n    \n}\n\n\n\n\n\nFetching a list of all records:\n\n\n\n\nNOTE: This method holds all rows in memory, so this should not be used if there is going to be large number of rows.\n\n\n\n\n    \nList\n \nvalues\n \n=\n \nscrollableQuery\n.\nrows\n(\nselect * from ScrollableQueryTest where value=\ntest\n)\n\n\n\n\n\nGrailsParameterMapRowMapper\n\n\nSee \nGrailsParameterMapRowMapper\n\n\nRow mapper which allows to convert data from a given ResultSet instance\nto a grails parameter map, which can be used for databinding.",
            "title": "Working with queries"
        },
        {
            "location": "/working-with-queries/#scrollablequery",
            "text": "See  ScrollableQuery",
            "title": "ScrollableQuery"
        },
        {
            "location": "/working-with-queries/#execute-a-closure-for-each-record",
            "text": "As you can see in the example below, we can specify the SQL query and provide the closure which is called for each record:       ScrollableQuery   scrollableQuery   =   new   ScrollableQuery ( new   ColumnMapRowMapper (),   dataSource ,   50 ) \n\n     scrollableQuery . eachRow ( select * from ScrollableQueryTest )   {   Object   row   - \n         println   row \n     }",
            "title": "Execute a closure for each record"
        },
        {
            "location": "/working-with-queries/#execute-a-closure-for-each-batch-of-records",
            "text": "Using  eachBatch  we can execute a closure for a batch of records.\nThis closure is called for a specified number of records. For example, code below prints size of each batch\n(which is 5) to console:       scrollableQuery . eachBatch ( select * from ScrollableQueryTest ,   5 )   {   List   batch   - \n         println   batchSize=${batch.size()} \n     }",
            "title": "Execute a closure for each batch of records"
        },
        {
            "location": "/working-with-queries/#fetching-a-list-of-all-records",
            "text": "NOTE: This method holds all rows in memory, so this should not be used if there is going to be large number of rows.        List   values   =   scrollableQuery . rows ( select * from ScrollableQueryTest where value= test )",
            "title": "Fetching a list of all records:"
        },
        {
            "location": "/working-with-queries/#grailsparametermaprowmapper",
            "text": "See  GrailsParameterMapRowMapper  Row mapper which allows to convert data from a given ResultSet instance\nto a grails parameter map, which can be used for databinding.",
            "title": "GrailsParameterMapRowMapper"
        },
        {
            "location": "/working-with-dates/",
            "text": "Gorm-tools provides a set of static utils which allow us to manipulate with dates much easier.\n\n\nDateUtil\n\n\nSee \nDateUtil\n\n\nParsing a date in a string\n\n\nstringToDate\n expects a string with date in the simple format \nyyyy-MM-dd\n and returns Date instance:\n\n\n     \nDate\n \ndate\n \n=\n \nDateUtil\n.\nstringToDate\n(\n2017-10-19\n)\n\n\n     \nassert\n \ndate\n\n     \nassert\n \ndate\n \n==\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd\n).\nparse\n(\n2017-10-19\n)\n\n\n\n\n\nit's a shortcut for \nconvertStringToDateTime\n\n\n     \nDate\n \ndate\n \n=\n \nDateUtil\n.\nconvertStringToDateTime\n(\n2017-10-19\n,\n \nyyyy-MM-dd\n)\n\n\n     \nassert\n \ndate\n\n     \nassert\n \ndate\n \n==\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd\n).\nparse\n(\n2017-10-19\n)\n\n\n\n\n\nConverting Date instance to a string\n\n\ndateToJsonString\n converts a date to the format \nyyyy-MM-dd'T'HH:mm:ss.SSSZ\n\n\n    \nDate\n \ndate\n \n=\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd HH:mm:ss\n).\nparse\n(\n2017-10-20 22:00:00\n)\n\n\n    \nString\n \nresult\n \n=\n \nDateUtil\n.\ndateToJsonString\n(\ndate\n)\n\n    \nassert\n \nresult\n \n==\n \ndate\n.\nformat\n(\nyyyy-MM-dd\nT\nHH:mm:ss.SSSZ\n)\n\n\n\n\n\nit's a shortcut for \ndateToString\n method which accepts a format\n\n\n    \nDate\n \ndate\n \n=\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd HH:mm:ss\n).\nparse\n(\n2017-10-20 22:00:00\n)\n\n\n    \nString\n \nresult\n \n=\n \nDateUtil\n.\ndateToString\n(\ndate\n,\n \nyyyy-MM-dd\nT\nHH:mm:ss.SSSZ\n)\n\n    \nassert\n \nresult\n \n==\n \ndate\n.\nformat\n(\nyyyy-MM-dd\nT\nHH:mm:ss.SSSZ\n)\n\n\n\n    \nresult\n \n=\n \nDateUtil\n.\ndateToString\n(\ndate\n)\n\n    \nassert\n \nresult\n \n==\n \ndate\n.\nformat\n(\nMM/dd/yyyy hh:mm:ss\n)\n\n\n\n\n\nGet the difference now and a specified date in hours\n\n\n    \nCalendar\n \ncalendar\n \n=\n \nCalendar\n.\ngetInstance\n()\n\n    \ncalendar\n.\nadd\n(\nCalendar\n.\nHOUR\n,\n \n1\n)\n\n    \ncalendar\n.\nadd\n(\nCalendar\n.\nMINUTE\n,\n \n30\n)\n\n\n    \nassert\n \n1L\n \n=\n \nDateUtil\n.\ngetDateDifference_inHours\n(\ncalendar\n.\ngetTime\n())\n\n\n\n\n\nGet the difference between dates\n\n\nWe can calculate get number of months between two dates, for example:\n\n\n    \nSimpleDateFormat\n \nformat\n \n=\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd\n)\n\n    \nDate\n \ndate1\n \n=\n \nformat\n.\nparse\n(\n2017-10-19\n)\n\n    \nDate\n \ndate2\n \n=\n \nformat\n.\nparse\n(\n2017-12-19\n)\n\n\n    \n2\n \n==\n \nDateUtil\n.\ngetMonthDiff\n(\ndate1\n,\n \ndate2\n)\n\n\n\n\n\nor number of days\n\n\n    \nDate\n \nnow\n \n=\n \nnew\n \nDate\n()\n\n\n    \nassert\n \n0\n \n==\n \nDateUtil\n.\ngetDaysBetween\n(\nnow\n,\n \nnow\n)\n\n    \nassert\n \n-\n10\n \n==\n \nDateUtil\n.\ngetDaysBetween\n(\nnow\n \n-\n \n10\n,\n \nnow\n)\n\n    \nassert\n  \n10\n \n==\n \nDateUtil\n.\ngetDaysBetween\n(\nnow\n \n+\n \n10\n,\n \nnow\n)\n\n\n\n\n\nMultiFormatDateConverter\n\n\nSee \nMultiFormatDateConverter\n\n\nUsing a universal date converter\n\n\n    \nMultiFormatDateConverter\n \nconverter\n \n=\n \nnew\n \nMultiFormatDateConverter\n()\n\n\n    \nDate\n \ndate\n \n=\n \nconverter\n.\nconvert\n(\n2017-10-13\n)\n          \n// passing date in format yyyy-MM-dd\n\n    \nDate\n \ndate\n \n=\n \nconverter\n.\nconvert\n(\n10/13/2017\n)\n          \n// passing date in format MM/dd/yy\n\n    \nDate\n \ndate\n \n=\n \nconverter\n.\nconvert\n(\n2017-10-13T10:00:00\n)\n \n// passing date in format yyyy-MM-dd\nT\nHH:mm:ss",
            "title": "Working with dates"
        },
        {
            "location": "/working-with-dates/#dateutil",
            "text": "See  DateUtil",
            "title": "DateUtil"
        },
        {
            "location": "/working-with-dates/#parsing-a-date-in-a-string",
            "text": "stringToDate  expects a string with date in the simple format  yyyy-MM-dd  and returns Date instance:        Date   date   =   DateUtil . stringToDate ( 2017-10-19 ) \n\n      assert   date \n      assert   date   ==   new   SimpleDateFormat ( yyyy-MM-dd ). parse ( 2017-10-19 )   it's a shortcut for  convertStringToDateTime        Date   date   =   DateUtil . convertStringToDateTime ( 2017-10-19 ,   yyyy-MM-dd ) \n\n      assert   date \n      assert   date   ==   new   SimpleDateFormat ( yyyy-MM-dd ). parse ( 2017-10-19 )",
            "title": "Parsing a date in a string"
        },
        {
            "location": "/working-with-dates/#converting-date-instance-to-a-string",
            "text": "dateToJsonString  converts a date to the format  yyyy-MM-dd'T'HH:mm:ss.SSSZ       Date   date   =   new   SimpleDateFormat ( yyyy-MM-dd HH:mm:ss ). parse ( 2017-10-20 22:00:00 ) \n\n     String   result   =   DateUtil . dateToJsonString ( date ) \n     assert   result   ==   date . format ( yyyy-MM-dd T HH:mm:ss.SSSZ )   it's a shortcut for  dateToString  method which accepts a format       Date   date   =   new   SimpleDateFormat ( yyyy-MM-dd HH:mm:ss ). parse ( 2017-10-20 22:00:00 ) \n\n     String   result   =   DateUtil . dateToString ( date ,   yyyy-MM-dd T HH:mm:ss.SSSZ ) \n     assert   result   ==   date . format ( yyyy-MM-dd T HH:mm:ss.SSSZ ) \n\n\n     result   =   DateUtil . dateToString ( date ) \n     assert   result   ==   date . format ( MM/dd/yyyy hh:mm:ss )",
            "title": "Converting Date instance to a string"
        },
        {
            "location": "/working-with-dates/#get-the-difference-now-and-a-specified-date-in-hours",
            "text": "Calendar   calendar   =   Calendar . getInstance () \n     calendar . add ( Calendar . HOUR ,   1 ) \n     calendar . add ( Calendar . MINUTE ,   30 ) \n\n     assert   1L   =   DateUtil . getDateDifference_inHours ( calendar . getTime ())",
            "title": "Get the difference now and a specified date in hours"
        },
        {
            "location": "/working-with-dates/#get-the-difference-between-dates",
            "text": "We can calculate get number of months between two dates, for example:       SimpleDateFormat   format   =   new   SimpleDateFormat ( yyyy-MM-dd ) \n     Date   date1   =   format . parse ( 2017-10-19 ) \n     Date   date2   =   format . parse ( 2017-12-19 ) \n\n     2   ==   DateUtil . getMonthDiff ( date1 ,   date2 )   or number of days       Date   now   =   new   Date () \n\n     assert   0   ==   DateUtil . getDaysBetween ( now ,   now ) \n     assert   - 10   ==   DateUtil . getDaysBetween ( now   -   10 ,   now ) \n     assert    10   ==   DateUtil . getDaysBetween ( now   +   10 ,   now )",
            "title": "Get the difference between dates"
        },
        {
            "location": "/working-with-dates/#multiformatdateconverter",
            "text": "See  MultiFormatDateConverter",
            "title": "MultiFormatDateConverter"
        },
        {
            "location": "/working-with-dates/#using-a-universal-date-converter",
            "text": "MultiFormatDateConverter   converter   =   new   MultiFormatDateConverter () \n\n     Date   date   =   converter . convert ( 2017-10-13 )            // passing date in format yyyy-MM-dd \n     Date   date   =   converter . convert ( 10/13/2017 )            // passing date in format MM/dd/yy \n     Date   date   =   converter . convert ( 2017-10-13T10:00:00 )   // passing date in format yyyy-MM-dd T HH:mm:ss",
            "title": "Using a universal date converter"
        },
        {
            "location": "/building-response-messages/",
            "text": "See \nDaoMessage\n\n\nGorm-tools provides a way to build message maps with information about a status of a domain instance.\nUses i18n messages.\n\n\nSaved and no saved messages\n\n\nThe example below shows how to build \nsaved\n message for a domain:\n\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nid:\n100\n,\nversion:\n1\n)\n\n\n    \nMap\n \nmsg\n \n=\n \nDaoMessage\n.\nsaved\n(\nuser\n)\n\n    \nassert\n \ndefault.saved.message\n \n==\n \nmsg\n.\ncode\n \n//i18 code\n\n    \nassert\n \n100\n \n==\n \nmsg\n.\nargs\n[\n1\n]\n\n\n\n\n\nList of available messages\n\n\n\n\nsaved\n\n\nnot saved\n\n\nupdated\n\n\nnot updated\n\n\ndeleted\n\n\nnot deleted\n\n\nnotFound\n\n\noptimisticLockingFailure - Another user has updated the resource while you were editing",
            "title": "Building response messages"
        },
        {
            "location": "/building-response-messages/#saved-and-no-saved-messages",
            "text": "The example below shows how to build  saved  message for a domain:       User   user   =   new   User ( id: 100 , version: 1 ) \n\n     Map   msg   =   DaoMessage . saved ( user ) \n     assert   default.saved.message   ==   msg . code   //i18 code \n     assert   100   ==   msg . args [ 1 ]",
            "title": "Saved and no saved messages"
        },
        {
            "location": "/building-response-messages/#list-of-available-messages",
            "text": "saved  not saved  updated  not updated  deleted  not deleted  notFound  optimisticLockingFailure - Another user has updated the resource while you were editing",
            "title": "List of available messages"
        },
        {
            "location": "/error-handling/",
            "text": "Gorm-tools provides its own types of exceptions to handle errors which relate to domains.\n\n\nDomainException\n\n\nSee \nDomainException\n\n\nAn extension of the default ValidationException. It is possible to pass the entity and the message map.\n\n\nDomainNotFoundException\n\n\nSee \nDomainNotFoundException\n\n\nAn extension of the DomainException to be able to handle rest request which should respond with 404 error.",
            "title": "Handling errors"
        },
        {
            "location": "/error-handling/#domainexception",
            "text": "See  DomainException  An extension of the default ValidationException. It is possible to pass the entity and the message map.",
            "title": "DomainException"
        },
        {
            "location": "/error-handling/#domainnotfoundexception",
            "text": "See  DomainNotFoundException  An extension of the DomainException to be able to handle rest request which should respond with 404 error.",
            "title": "DomainNotFoundException"
        },
        {
            "location": "/mapql/",
            "text": "Overview\n\n\nThe gorm dao's come with a \nlist(criteriaMap, closure)\n method. It allows to get list of entities restricted by\nthe properties in the \ncriteriaMap\n. The map could be passed as JSON string or Map. All restrictions should be under \ncriteria\n keyword by default, see example\nbellow.\n\n\nAnything in the optional closure will be passed into Gorm/Hibernate criteria closure\n\n\nThe query language is largely based on \nMongo's\n\nwith inspiration from \njson-sql\n as well\n\n\nExample\n\n\nOrg.dao.list([\n  criteria: [name: \nVirgin%\n, type: \nNew\n],\n  order: {name:1},\n  max: 20\n]){\n  gt \nid\n, 5\n}\n\n\n\n\nThe same result can be reached with criteria:\n\n\nCriteria criteria = Org.createCriteria()\ncriteria.list(max: 20) {\n    like \nname\n, \nNam%\n\n    eq \ntype\n, \nNew\n\n    gt \nid\n, 5\n}\n\n\n\n\nCriteria options\n\n\nLogical\n\n\n\n\n\n\n\n\nOp\n\n\nDescription\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\n$and\n\n\nonly needed for special conditions\n\n\n$and: [ {name: 'John'}, {age: 12} ]\n \n same as \nname: 'John', age: 12\n\n\n\n\n\n\n$or\n\n\n\"ors\" them all\n\n\n$or: [ {name: 'John'}, {age: 12} ]\n \n \n$or: {name: 'John', age: 12 }\n\n\n\n\n\n\n$not\n\n\nALL not equal, !=, \n\n\n$not:{ name: 'John', age: 12\n}\n\n\n\n\n\n\n$nor\n\n\nANY not equal\n\n\n$nor:{ name: 'John', age: 12\n}\n\n\n\n\n\n\n\n\nComparison\n\n\n\n\n\n\n\n\nOp\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n$gt\n\n\n\n\nsalary\n: {\n$gt\n: 10000}\n\n\n\n\n\n\n$gte\n\n\n=\n\n\nsalary\n: {\n$gte\n: 10000}\n\n\n\n\n\n\n$lt\n\n\n\n\nsalary\n: {\n$lt\n: 10000}\n\n\n\n\n\n\n$lte\n\n\n=\n\n\nsalary\n: {\n$lte\n: 10000}\n\n\n\n\n\n\n$between\n\n\nWhere the property value is between two distinct values\n\n\nage\n: {\n$between\n: [18, 35]}\n\n\n\n\n\n\n$like\n\n\nEquivalent to SQL like expression\n\n\nname\n: {\n$like\n: \nJoh%\n}\n\n\n\n\n\n\n$ilike\n\n\nA case-insensitive 'like' expression, auto appends \n%\n\n\nname\n: {\n$ilike\n: \nJoh\n}\n\n\n\n\n\n\n$ne\n\n\nnot equal, !=, \n\n\nage\n : {\n$ne\n : 12}}\n\n\n\n\n\n\n$in\n\n\nMatch any value in array\n\n\n{\nfield\n : {\n$in\n : [value1, value2, ...]}\n\n\n\n\n\n\n$nin\n\n\nNot match any value in array\n\n\n{\nfield\n : {\n$nin\n : [value1, value2, ...]}}\n\n\n\n\n\n\n$isNull\n\n\n\n\n\n\n\n\n\n\n$isNotNull\n\n\n\n\n\n\n\n\n\n\n\n\nBellow will be a list of supported syntax for params in json format, which is supported:\n\n\nsomething like this should work too when combining\n\n\namount: {\n    $gt: 5.0,\n    $lt: 15.50,\n    $ne: 9.99\n}\n\n\n\n\n{\n\n    \ncriteria\n:\n \n{\n\n      \nponum\n:\nabc\n,\n \n/*\n \nif\n \nits\n \na\n \nsingle\n \nvalue\n \neq\n \nis\n \ndefault,\n \nif\n \nit\n \ncontains\n \n%\n \nthen\n \nit\n \nuses\n \nilike\n \n*/\n\n      \nreconciled\n:\n \ntrue\n,\n \n/*\n \nboolean\n \n*/\n\n      \ntranDate\n:\n \n2012-04-23T00:00:00.000Z\n,\n \n/*\n \ndate\n \n*/\n\n      \ncustomer.id\n:\n \n101\n,\n\n      \ncustomerId\n:\n \n101\n,\n \n/*works\n \nin\n \nthe\n \nsame\n \nway\n \nas\n \n`customer.id:101`\n \n*/\n\n      \ncustomer\n:{\nid\n:\n101\n},\n \n/*\n \nor\n \nobject\n \nway\n \n*/\n\n      \nor\n:{\n \n/*TODO:\n \nworks\n \nonly\n \nif\n \nit\n \nis\n \none\n \nin\n \n`criteria`,\n \nand\n \ncurrently\n \nonly\n \non\n \nfirst\n \nlevel*/\n\n        \ncustomer.name\n:[\n$ilike\n:\n \nwal\n],\n\n        \ncustomer.num\n:[\n$like\n:\n \nwal%\n]\n\n      \n},\n\n      \ndocType\n:\n \n[\nPA\n,\nCM\n],\n \n/*\n \nan\n \narray\n \nmeans\n \nit\n \nwill\n \nuse\n \nin/inList\n \n*/\n  \n      \ndocType\n:\n \n[\n$in\n:\n \n[\nPA\n,\nCM\n]],\n \n/*\n \nthe\n \nabove\n \nins\n \nwould\n \nbe\n \na\n \nshort\n \ncut\n \nfor\n \nthis*/\n\n      \n//deprecate\n \ndocType\n:\n \n[\n$in\nPA\n \n,\nCM\n],\n \n/*\n \nthe\n \nabove\n \nins\n \nwould\n \nbe\n \na\n \nshort\n \ncut\n \nfor\n \nthis*/\n\n      \ntranType.id\n:\n \n[\n$nin\n:\n[\n1\n,\n2\n,\n3\n]],\n/*\n \nwill\n \ntranslate\n \nto\n \nnot{ in(\ntranType.id\n,[1,2,3])]\n \n*/\n\n      \ntranType.id\n:\n \n[\n$not in\n:\n[\n1\n,\n2\n,\n3\n]],\n/*\n \nwill\n \ntranslate\n \nto\n \nnot{ in(\ntranType.id\n,[1,2,3])]\n \n*/\n\n      \nrefnum\n:\n \n[\n$ilike\n:\n \n123\n],\n \n/*\n \na\n \ncase-insensitive\n \nlike\n \nexpression\n \nappend\n \nthe\n \n%\n \n*/\n\n      \nrefnum\n:\n \n[\n$like\n:\n \n123%\n],\n \n/*\n \nequivalent\n \nto\n \nSQL\n \nlike\n \nexpression\n \n*/\n\n      \namount\n:\n \n[\n$between\n:\n[\n0\n,\n100\n]],\n \n/*\n \nbetween\n \nvalue\n \n*/\n\n      \noldAmount.gt()\n:\n \norigAmount\n/*\n \ngreater\n \nthan\n \nvalue\n,\n \nthe\n \nsame\n \nas\n \nbellow*/\n\n      \noldAmount\n:\n \n[\ngt()\n,\norigAmount\n],\n \n/*\n \ngreater\n \nthan\n \nvalue\n \n*/\n\n      \noldAmount\n:\n \n[\nge()\n,\norigAmount\n],\n \n/*\n \ngreater\n \nor\n \nequal\n \nthan\n \nvalue\n \n*/\n\n\n      oldAmount\n:\n \n[\nlt()\n,\norigAmount\n],\n \n/*\n \nless\n \nthan\n \nvalue\n \n*/\n\n      \noldAmount\n:\n \n[\nle()\n,\norigAmount\n],\n \n/*\n \nless\n \nor\n \nequal\n \nthan\n \nvalue\n \n*/\n\n      \namount\n:\n \n[\nne()\n,\n50\n],\n \n/*not\n \nequal*/\n\n      \nstatus.id\n:\n \n[\n1\n,\n2\n,\n3\n],\n \n/*\n \nan\n \narray\n \nmeans\n \nit\n \nwill\n \nuse\n \nin/inList\n \n*/\n\n      \nstatus\n:\n \n[{\nid\n:\n1\n},{\nid\n:\n2\n},{\nid\n:\n3\n}],\n \n/*\n \nan\n \narray\n \nmeans\n \nit\n \nwill\n \nuse\n \nin/inList\n \n*/\n\n      \nstatus\n:\n \n[\nisNull()\n],\n \n/*\n \ntranslates\n \nto\n \nisNull*/\n\n    \n},\n\n  \nsort\n:[{\ntranDate\n:\nASC\n},{\ncustomer.name\n,\ndesc\n}]\n\n\n}\n\n\n\n\nQuick Search\n\n\nQuick search - ability to search by one string in criteria filters against several domain fields, the value for quick\nsearch can be passed in \nquickSearch\n or \nq\n keywords. The list of fields should be specified in static property \nquickSearchFields\n, see bellow:\n\n\nclass\n \nOrg\n \n{\n\n    \nString\n \nname\n\n    \nAddress\n \naddress\n\n\n    \nstatic\n \nquickSearchFields\n \n=\n \n[\nname\n,\n \naddress.city\n]\n\n    \n...\n\n\n\nSo intelligent search will add \n%\n automatically for cases when searchable property is String, if quick search string doesn't have it and will apply \nilike\n statement\nfor each field in \nquickSearchFields\n.\n\n\nOrg\n.\ndao\n.\nsearch\n([\ncriteria:\n \n[\nquickSearch:\n \nabc\n],\n \nmax:\n \n20\n])\n\n\n\n\n\nCriteria\n \ncriteria\n \n=\n \nOrg\n.\ncreateCriteria\n()\n\n\ncriteria\n.\nlist\n(\nmax:\n \n20\n)\n \n{\n\n    \nor\n \n{\n\n        \nilike\n \nname\n,\n \nabc%\n\n        \nilike\n \naddress.city\n,\n \nabc%\n\n    \n}\n\n\n}\n\n\n\nKeep in mind that quickSearch has higher priority then regular search fields, and if params are\n\n[criteria: [quickSearch: \nabc\n, id: 5]]\n, then \nid\n restriction will be ignored, but criteria that is passed to search\nas closure will be executed in any case\n\n\nCount totals\n\nTODO: add count totals that should work in the same way as search",
            "title": "Criteria MapQL"
        },
        {
            "location": "/mapql/#overview",
            "text": "The gorm dao's come with a  list(criteriaMap, closure)  method. It allows to get list of entities restricted by\nthe properties in the  criteriaMap . The map could be passed as JSON string or Map. All restrictions should be under  criteria  keyword by default, see example\nbellow.  Anything in the optional closure will be passed into Gorm/Hibernate criteria closure  The query language is largely based on  Mongo's \nwith inspiration from  json-sql  as well  Example  Org.dao.list([\n  criteria: [name:  Virgin% , type:  New ],\n  order: {name:1},\n  max: 20\n]){\n  gt  id , 5\n}  The same result can be reached with criteria:  Criteria criteria = Org.createCriteria()\ncriteria.list(max: 20) {\n    like  name ,  Nam% \n    eq  type ,  New \n    gt  id , 5\n}",
            "title": "Overview"
        },
        {
            "location": "/mapql/#criteria-options",
            "text": "",
            "title": "Criteria options"
        },
        {
            "location": "/mapql/#logical",
            "text": "Op  Description  Examples      $and  only needed for special conditions  $and: [ {name: 'John'}, {age: 12} ]    same as  name: 'John', age: 12    $or  \"ors\" them all  $or: [ {name: 'John'}, {age: 12} ]     $or: {name: 'John', age: 12 }    $not  ALL not equal, !=,   $not:{ name: 'John', age: 12 }    $nor  ANY not equal  $nor:{ name: 'John', age: 12 }",
            "title": "Logical"
        },
        {
            "location": "/mapql/#comparison",
            "text": "Op  Description  Example      $gt   salary : { $gt : 10000}    $gte  =  salary : { $gte : 10000}    $lt   salary : { $lt : 10000}    $lte  =  salary : { $lte : 10000}    $between  Where the property value is between two distinct values  age : { $between : [18, 35]}    $like  Equivalent to SQL like expression  name : { $like :  Joh% }    $ilike  A case-insensitive 'like' expression, auto appends  %  name : { $ilike :  Joh }    $ne  not equal, !=,   age  : { $ne  : 12}}    $in  Match any value in array  { field  : { $in  : [value1, value2, ...]}    $nin  Not match any value in array  { field  : { $nin  : [value1, value2, ...]}}    $isNull      $isNotNull       Bellow will be a list of supported syntax for params in json format, which is supported:  something like this should work too when combining  amount: {\n    $gt: 5.0,\n    $lt: 15.50,\n    $ne: 9.99\n}  { \n     criteria :   { \n       ponum : abc ,   /*   if   its   a   single   value   eq   is   default,   if   it   contains   %   then   it   uses   ilike   */ \n       reconciled :   true ,   /*   boolean   */ \n       tranDate :   2012-04-23T00:00:00.000Z ,   /*   date   */ \n       customer.id :   101 , \n       customerId :   101 ,   /*works   in   the   same   way   as   `customer.id:101`   */ \n       customer :{ id : 101 },   /*   or   object   way   */ \n       or :{   /*TODO:   works   only   if   it   is   one   in   `criteria`,   and   currently   only   on   first   level*/ \n         customer.name :[ $ilike :   wal ], \n         customer.num :[ $like :   wal% ] \n       }, \n       docType :   [ PA , CM ],   /*   an   array   means   it   will   use   in/inList   */   \n       docType :   [ $in :   [ PA , CM ]],   /*   the   above   ins   would   be   a   short   cut   for   this*/ \n       //deprecate   docType :   [ $in PA   , CM ],   /*   the   above   ins   would   be   a   short   cut   for   this*/ \n       tranType.id :   [ $nin : [ 1 , 2 , 3 ]], /*   will   translate   to   not{ in( tranType.id ,[1,2,3])]   */ \n       tranType.id :   [ $not in : [ 1 , 2 , 3 ]], /*   will   translate   to   not{ in( tranType.id ,[1,2,3])]   */ \n       refnum :   [ $ilike :   123 ],   /*   a   case-insensitive   like   expression   append   the   %   */ \n       refnum :   [ $like :   123% ],   /*   equivalent   to   SQL   like   expression   */ \n       amount :   [ $between : [ 0 , 100 ]],   /*   between   value   */ \n       oldAmount.gt() :   origAmount /*   greater   than   value ,   the   same   as   bellow*/ \n       oldAmount :   [ gt() , origAmount ],   /*   greater   than   value   */ \n       oldAmount :   [ ge() , origAmount ],   /*   greater   or   equal   than   value   */        oldAmount :   [ lt() , origAmount ],   /*   less   than   value   */ \n       oldAmount :   [ le() , origAmount ],   /*   less   or   equal   than   value   */ \n       amount :   [ ne() , 50 ],   /*not   equal*/ \n       status.id :   [ 1 , 2 , 3 ],   /*   an   array   means   it   will   use   in/inList   */ \n       status :   [{ id : 1 },{ id : 2 },{ id : 3 }],   /*   an   array   means   it   will   use   in/inList   */ \n       status :   [ isNull() ],   /*   translates   to   isNull*/ \n     }, \n   sort :[{ tranDate : ASC },{ customer.name , desc }]  }   Quick Search  Quick search - ability to search by one string in criteria filters against several domain fields, the value for quick\nsearch can be passed in  quickSearch  or  q  keywords. The list of fields should be specified in static property  quickSearchFields , see bellow:  class   Org   { \n     String   name \n     Address   address \n\n     static   quickSearchFields   =   [ name ,   address.city ] \n     ...  \nSo intelligent search will add  %  automatically for cases when searchable property is String, if quick search string doesn't have it and will apply  ilike  statement\nfor each field in  quickSearchFields .  Org . dao . search ([ criteria:   [ quickSearch:   abc ],   max:   20 ])   Criteria   criteria   =   Org . createCriteria ()  criteria . list ( max:   20 )   { \n     or   { \n         ilike   name ,   abc% \n         ilike   address.city ,   abc% \n     }  }  \nKeep in mind that quickSearch has higher priority then regular search fields, and if params are [criteria: [quickSearch:  abc , id: 5]] , then  id  restriction will be ignored, but criteria that is passed to search\nas closure will be executed in any case  Count totals \nTODO: add count totals that should work in the same way as search",
            "title": "Comparison"
        }
    ]
}
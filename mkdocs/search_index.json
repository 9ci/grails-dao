{
    "docs": [
        {
            "location": "/",
            "text": "________                                           _.-````'-,_\n     /  _____/  ___________  _____                   ,-'`           `'-.,_\n    /   \\  ___ /  _ \\_  __ \\/     \\          /)     (\\       9ci's       '``-.\n    \\    \\_\\  (  \n<\n_> )  | \\/  Y Y  \\        ( ( .,-') )    Yak Works         ```\n     \\______  /\\____/|__|  |__|_|  /         \\ '   (_/                         !!\n            \\/                   \\/           |       /)           '           !!!\n  ___________           .__                   ^\\    ~'            '     !    !!!!\n  \\__    ___/___   ____ |  |   ______           !      _/! , !   !  ! !  !   !!!\n    |    | /  _ \\ /  _ \\|  |  /  ___/            \\Y,   |!!!  !  ! !!  !! !!!!!!!\n    |    |(  \n<\n_> |  \n<\n_> )  |__\\___ \\               `!!! !!!! !!  )!!!!!!!!!!!!!\n    |____| \\____/ \\____/|____/____  >               !!  ! ! \\( \\(  !!!|/!  |/!\n                                  \\/               /_(      /_(/_(    /_(  /_(   \n            v3.3.2-SNAPSHOT\n\n\n\n\n\nThis is a library of tools to help standardize and simplify the service and Restful controller layer business logic for \ndomains and is the basis for the \nGorm Rest API plugin\n. \nThere are 2 primary patterns this library enables as detailed below for Repositories\nand Mango ( A mongo query like way to get data with a Map)\n\n\nDomain Repository Services\n\n\njump to reference\n\n\nA repository is a [Domain Driven Design][] pattern. Used a a place logic to validate, bind, persist and query data that resides \neither in a database or NoSql (via GORM usually of course).\nThe design pattern here is a bit similiar to \nSpring's Repository pattern\n\nand Grails GORM's new \nData Services\n pattern.\n\n\nGoals\n\n\n\n\nStandardization\n: a clean common pattern across our apps for domain service layer logic that \n  reduces boiler plate in both services as well as controllers.\n\n\nTransactional Saves\n: every save() or persist() is wrapped in a transaction if one doesn't already exist. \n  This is critical when there are cascading saves and updates.\n\n\nRuntimeException Rollback\n: saves or \npersist()\n always occur with failOnError:true so a RuntimeException is \n  thrown for both DataAccessExceptions as well a validation exceptions.\n  This is critical for deeply nested domain logic dealing with saving multiple domains chains.\n\n\nFast Data Binding Service\n: databinding from maps (and thus JSON) has to be fast \n  and therefore maps and json are a first class citizen where it belongs in the data service layer instead of the controller layer. \n  Eliminates boiler plate in getting data from the database to Gorm to JSON Map then back again.\n\n\nEvents \n Validation\n: the Repository allows a central place to do events such as beforeSave, beforeValidate, etc \n  so as not to pollute the domain class. This pattern makes it easier to keeps the special logic in a transaction as well. \n  Allows validation outside of constraints to persistence without needing to modify the domain source.\n\n\nEvents with Flushing\n: As mentioned in the Gorm docs, \"Do not attempt to flush the session within an event \n  (such as with obj.save(flush:true)). Since events are fired during flushing this will cause a StackOverflowError.\". \n  Putting the event business logic in the Repository keeps it all in a normal transaction and a flush is perfectly fine.  \n\n\nOverride Plugin's Domain Logic\n: Since the Repository is a service this also easily allows default logic in a provided \n  plugin to be overriden in an application. For example, I may have a CustomerRepo in a plugin that deals with deault common \n  logic to validate address. I can then implement a CustomerRepo in an application and it will override the spring bean\n  just as it does for a service. \n\n\n\n\nMango Query\n\n\nThe primary motive here is to create an easy dynamic map based way to query any Gorm Datastore (SQL or NoSQL). \nUsing a simple map that can come from json, yaml, groovy config etc... \nA huge motivating factor being able is to be able to have a powerful and flexible way to query using json from a REST \nbased client without having to use GraphQL (the only other clean alternative)\nThe Repositories and RestApiController come with a \nquery(criteriaMap, closure)\n method. It allows you to get a paginated \nlist of entities restricted by the properties in the \ncriteriaMap\n.\n\n\n\n\nA lot of inspiration was drawn from \nRestdb.io\n\n\nthe query language is similar to \nMongo's\n\n\nand CouchDB's new \nMango selector-syntax\n.\n\n\nAlso inspired by \njson-sql\n\n\n\n\n\n\n \nWhilst selectors have many similarities with MongoDB query documents, \nthese arise more from a similarity of purpose and do not necessarily extend to commonality of function or result.\n\n\n\n\nExample\n\nfor example, sending a JSON search param that looks like this\n\n{\n\n  \nname\n:\n \nBill%\n,\n\n  \ntype\n:\n \nNew\n,\n\n  \nage\n:\n \n{\n$gt\n:\n \n65\n}\n\n\n}\n\n\n\nwould get converted to the equivalent criteria\n\n\ncriteria\n.\nlist\n \n{\n\n    \nilike\n \nname\n,\n \nBill%\n\n    \neq\n \ntype\n,\n \nNew\n\n    \ngt\n \nage\n,\n \n65\n\n\n}\n\n\n\n\n\nGetting started\n\n\nTo use the Gorm-Tools add the dependency on the plugin to your build.gradle file:\n\n\nruntime \norg.grails.plugins:gorm-tools:@VERSION@\n\n\n\n\n\nAnd you can start using the plugin by calling the repository methods on domain classes. \nThe plugin adds several persistence methods to domain classes. Which delegates to repository classes. This includes persist(), create(params), update(update), remove()\n\n\nSee \nRepository\n for more details",
            "title": "Overview"
        },
        {
            "location": "/#domain-repository-services",
            "text": "jump to reference  A repository is a [Domain Driven Design][] pattern. Used a a place logic to validate, bind, persist and query data that resides \neither in a database or NoSql (via GORM usually of course).\nThe design pattern here is a bit similiar to  Spring's Repository pattern \nand Grails GORM's new  Data Services  pattern.",
            "title": "Domain Repository Services"
        },
        {
            "location": "/#goals",
            "text": "Standardization : a clean common pattern across our apps for domain service layer logic that \n  reduces boiler plate in both services as well as controllers.  Transactional Saves : every save() or persist() is wrapped in a transaction if one doesn't already exist. \n  This is critical when there are cascading saves and updates.  RuntimeException Rollback : saves or  persist()  always occur with failOnError:true so a RuntimeException is \n  thrown for both DataAccessExceptions as well a validation exceptions.\n  This is critical for deeply nested domain logic dealing with saving multiple domains chains.  Fast Data Binding Service : databinding from maps (and thus JSON) has to be fast \n  and therefore maps and json are a first class citizen where it belongs in the data service layer instead of the controller layer. \n  Eliminates boiler plate in getting data from the database to Gorm to JSON Map then back again.  Events   Validation : the Repository allows a central place to do events such as beforeSave, beforeValidate, etc \n  so as not to pollute the domain class. This pattern makes it easier to keeps the special logic in a transaction as well. \n  Allows validation outside of constraints to persistence without needing to modify the domain source.  Events with Flushing : As mentioned in the Gorm docs, \"Do not attempt to flush the session within an event \n  (such as with obj.save(flush:true)). Since events are fired during flushing this will cause a StackOverflowError.\". \n  Putting the event business logic in the Repository keeps it all in a normal transaction and a flush is perfectly fine.    Override Plugin's Domain Logic : Since the Repository is a service this also easily allows default logic in a provided \n  plugin to be overriden in an application. For example, I may have a CustomerRepo in a plugin that deals with deault common \n  logic to validate address. I can then implement a CustomerRepo in an application and it will override the spring bean\n  just as it does for a service.",
            "title": "Goals"
        },
        {
            "location": "/#mango-query",
            "text": "The primary motive here is to create an easy dynamic map based way to query any Gorm Datastore (SQL or NoSQL). \nUsing a simple map that can come from json, yaml, groovy config etc... \nA huge motivating factor being able is to be able to have a powerful and flexible way to query using json from a REST \nbased client without having to use GraphQL (the only other clean alternative)\nThe Repositories and RestApiController come with a  query(criteriaMap, closure)  method. It allows you to get a paginated \nlist of entities restricted by the properties in the  criteriaMap .   A lot of inspiration was drawn from  Restdb.io  the query language is similar to  Mongo's  and CouchDB's new  Mango selector-syntax .  Also inspired by  json-sql     \nWhilst selectors have many similarities with MongoDB query documents, \nthese arise more from a similarity of purpose and do not necessarily extend to commonality of function or result.   Example \nfor example, sending a JSON search param that looks like this { \n   name :   Bill% , \n   type :   New , \n   age :   { $gt :   65 }  }  \nwould get converted to the equivalent criteria  criteria . list   { \n     ilike   name ,   Bill% \n     eq   type ,   New \n     gt   age ,   65  }",
            "title": "Mango Query"
        },
        {
            "location": "/#getting-started",
            "text": "To use the Gorm-Tools add the dependency on the plugin to your build.gradle file:  runtime  org.grails.plugins:gorm-tools:@VERSION@   And you can start using the plugin by calling the repository methods on domain classes. \nThe plugin adds several persistence methods to domain classes. Which delegates to repository classes. This includes persist(), create(params), update(update), remove()  See  Repository  for more details",
            "title": "Getting started"
        },
        {
            "location": "/repository/intro/",
            "text": "Quick Start Example\n\n\nTo show what Repository data services are all about let\u2019s walk through an example.\n\n\nDomain setup\n\n\nLets assume we are setting up a way to track details for this Project. We might setup a couple of domains like this. \n\n\n//change the default contraints to be nullable:true\n\n\ngorm\n.\ndefault\n.\nconstraints\n \n=\n \n{\n\n    \n*\n(\nnullable:\ntrue\n)\n\n\n}\n\n\n\n@GrailsCompileStatic\n\n\nclass\n \nProject\n \n{\n\n    \nString\n \nname\n\n    \nString\n \ndescription\n\n\n    \nGitHubInfo\n \ngitHubInfo\n \n\n\n\n}\n\n\n\n@GrailsCompileStatic\n\n\nclass\n \nGitHubInfo\n \n{\n\n    \nLong\n \nrepId\n         \n//1829344\n\n    \nString\n \nslug\n         \n//yakworks/gorm-tools\n\n    \nString\n \ndescription\n  \n//gorm tools for a clean shaved yak\n\n\n}\n\n\n\n\n\nand lets say we have a map, perhaps that came from a restful json request or some other service, test data etc...\n\n\nparams\n \n=\n \n[\n\n    \nname:\n \ngorm-tools\n,\n\n    \ngitHubInfo:\n \n[\n\n        \nrepId:\n \n1829344\n,\n\n        \nslug:\n \nyakworks/gorm-tools\n,\n\n    \n]\n\n\n]\n\n\n\n\n\nStock Grails Gorm\n\n\nUsing stock Grails\n \nGorm\n we would probably implement something like the following \nsimplified boiler plate design pattern for the \nC\n in CRUD\n\n\n@GrailsCompileStatic\n \n@Transactional\n\n\nclass\n \nProjectService\n \n{\n\n\n    \nProject\n \ncreateNew\n(\nMap\n \ndata\n){\n\n        \ndef\n \nproject\n \n=\n \nnew\n \nProject\n()\n\n        \nproject\n.\nproperties\n \n=\n \ndata\n\n        \nproject\n.\nsave\n(\nfailOnError:\ntrue\n)\n \n//throw runtime to roll back if error\n\n    \n}\n\n\n    \n//.... other imps\n\n\n}\n\n\n\n// elsewhwere, probably in a controller action, we would inject the service and use it to save\n\n\n@Autowired\n \nProjectService\n \nprojectService\n\n\n...\n\n\nprojectService\n.\ncreateNew\n(\nparams\n)\n\n\n\n or perhaps we would do it with the new Data Services\n\n\nUsing the Repository\n\n\nWith this Gorm repository plugin\n, we have shaved the yak for you and each domain has a Repository automatically \nsetup for this pattern. So with this plugin all the boiler plate from above can be replaced with 1 line!\n\n\n// elsewhere, probably in a controller action. \n\n\nProject\n.\ncreate\n(\nparams\n)\n\n\n\n\n\nThats it. The \nProject.create()\n actually delegates to the Default\nGormRepo\n.create(). The \ncreate\n is wrapped in a transaction, creates the intance,\nbinds the data and defaults to saving with \nfailOnError:true\n. \nLike all transactional methods if the method is called from inside another transaction it will use it\notherwise it creates a new one. \n\n\n\n\n \nOther Repository Domain Methods\n\nYou can do the same thing as above for an \nupdate\n or \ndelete\n. \nThe details of whats available can be seen in the \nGormRepoEntity\n trait or in the \nGormRepoEntity source\n and are outlined below\n\n\n\n\nTesting the Domain\n\n\nIf you used the script to create the domains then the tests will already be in place for us or you can add one manually like so.\n\n\npackage\n \ntesting\n\n\n\nimport\n \ngorm.tools.testing.DomainAutoTest\n\n\nimport\n \nspock.lang.Specification\n\n\n\nclass\n \nProjectSpec\n \nextends\n \nDomainAutoTest\nProject\n \n{\n\n    \n/** automatically runs tests on pxersist(), create(), update(), delete().*/\n\n\n}\n\n\n\n\n\nNotice the absence of test methods? Running with the the mantra of \"convetion over configuration\" and \"intelligent defaults\"\n\nDomainAutoTest\n will mock the domain, setup and create the data for you then exercise the domain and the default repository service for you.\nWe'll see in the next section how to override the automated tests in the DomainAutoTest. \n\n\nImplementing ProjectRepo Service\n\n\nThe \nDefaultGormRepo\n that is setup for the Project domain will of course not always be adequate for the business logic.\nAgain running with the \"intelligent defaults but easy to override\" mantra we can easily and selectively override the defaults in the repository. \nLets say we want to do something more advanced during the create such as validate and retrieve info from GitHub. \nIts not recomended to autowire beans into the domains for performance reasons\nIt can also be tricky and at times fairly messy trying to modify or create domains using gorm's hibernate inspired event methods.\nSuch as \nbeforeCreate\n inside the Project domain and deal with flushing.\n\n\nWe can abstract out the logic into a ProjectRepo. \n\n\nLets say we wanted to use a service to validate Github repo and retrieve the description on create.\nWe can add a class to the \ngrails-app/repository\n directory as in the following example.\n\n\npackage\n \ntracker\n\n\n\n@CompileStatic\n\n\nclass\n \nProjectRepo\n \nimplements\n \nGormRepo\nProject\n{\n\n\n    \n@Autowired\n \nGitHubApi\n \ngitHubApi\n\n\n    \n//event method used to update the descriptions with the ones in github\n\n    \nvoid\n \nafterCreate\n(\nProject\n \nproject\n,\n \nMap\n \nparams\n){\n\n        \nMap\n \nrepoInfo\n \n=\n \ngitHubApi\n.\ngetGitRepo\n(\nparams\n.\ngitHubRepo\n)\n\n        \n//check that it was found using the slug or repoId\n\n        \nif\n \n(!\nrepoInfo\n)\n \n            \nthrow\n \nnew\n \nDataRetrievalFailureException\n(\nGithub Repo is invalid for ${params.gitHubInfo}\n)\n\n\n        \nif\n(\nrepoInfo\n.\ndescription\n){\n\n            \n//force the gitHubRepo.description to be whats in github\n\n            \nproject\n.\ngitHubInfo\n.\ndescription\n \n=\n \nrepoInfo\n.\ndescription\n\n            \n//update project.description to be the same if its null\n\n            \nproject\n.\ndescription\n \n=\n \nproject\n.\ndescription\n \n?:\n \nrepoInfo\n.\ndescription\n\n            \nproject\n.\npersist\n()\n \n//optional\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n// elsewhere, you can call and it will be automatically taken care of\n\n\nProject\n.\ncreate\n(\nparams\n)\n\n\n\n\n\nEvents methods and fired spring events are run inside the inherited transaction and as usual an uncaught runtime exception will rollback.\nThe \npersist\n methods is another addition to the domains added by the GormRepoEntity trait. In the example above its not really needed as \nthe changes will be flushed during the transaction commit. They are here to doc whats happening \nand so that validation failures can be easily seen.\n\n\nTesting the ProjectRepo Changes\n\n\nclass ProjectSpec extends Specification implements DomainAutoTest\nProject\n {\nTODO\n}",
            "title": "Quick Start"
        },
        {
            "location": "/repository/intro/#quick-start-example",
            "text": "To show what Repository data services are all about let\u2019s walk through an example.",
            "title": "Quick Start Example"
        },
        {
            "location": "/repository/intro/#domain-setup",
            "text": "Lets assume we are setting up a way to track details for this Project. We might setup a couple of domains like this.   //change the default contraints to be nullable:true  gorm . default . constraints   =   { \n     * ( nullable: true )  }  @GrailsCompileStatic  class   Project   { \n     String   name \n     String   description \n\n     GitHubInfo   gitHubInfo   }  @GrailsCompileStatic  class   GitHubInfo   { \n     Long   repId           //1829344 \n     String   slug           //yakworks/gorm-tools \n     String   description    //gorm tools for a clean shaved yak  }   and lets say we have a map, perhaps that came from a restful json request or some other service, test data etc...  params   =   [ \n     name:   gorm-tools , \n     gitHubInfo:   [ \n         repId:   1829344 , \n         slug:   yakworks/gorm-tools , \n     ]  ]",
            "title": "Domain setup"
        },
        {
            "location": "/repository/intro/#stock-grails-gorm",
            "text": "Using stock Grails   Gorm  we would probably implement something like the following \nsimplified boiler plate design pattern for the  C  in CRUD  @GrailsCompileStatic   @Transactional  class   ProjectService   { \n\n     Project   createNew ( Map   data ){ \n         def   project   =   new   Project () \n         project . properties   =   data \n         project . save ( failOnError: true )   //throw runtime to roll back if error \n     } \n\n     //.... other imps  }  // elsewhwere, probably in a controller action, we would inject the service and use it to save  @Autowired   ProjectService   projectService  ...  projectService . createNew ( params )  \n or perhaps we would do it with the new Data Services",
            "title": "Stock Grails Gorm"
        },
        {
            "location": "/repository/intro/#using-the-repository",
            "text": "With this Gorm repository plugin , we have shaved the yak for you and each domain has a Repository automatically \nsetup for this pattern. So with this plugin all the boiler plate from above can be replaced with 1 line!  // elsewhere, probably in a controller action.   Project . create ( params )   Thats it. The  Project.create()  actually delegates to the Default GormRepo .create(). The  create  is wrapped in a transaction, creates the intance,\nbinds the data and defaults to saving with  failOnError:true . \nLike all transactional methods if the method is called from inside another transaction it will use it\notherwise it creates a new one.      Other Repository Domain Methods \nYou can do the same thing as above for an  update  or  delete . \nThe details of whats available can be seen in the  GormRepoEntity  trait or in the  GormRepoEntity source  and are outlined below",
            "title": "Using the Repository"
        },
        {
            "location": "/repository/intro/#testing-the-domain",
            "text": "If you used the script to create the domains then the tests will already be in place for us or you can add one manually like so.  package   testing  import   gorm.tools.testing.DomainAutoTest  import   spock.lang.Specification  class   ProjectSpec   extends   DomainAutoTest Project   { \n     /** automatically runs tests on pxersist(), create(), update(), delete().*/  }   Notice the absence of test methods? Running with the the mantra of \"convetion over configuration\" and \"intelligent defaults\" DomainAutoTest  will mock the domain, setup and create the data for you then exercise the domain and the default repository service for you.\nWe'll see in the next section how to override the automated tests in the DomainAutoTest.",
            "title": "Testing the Domain"
        },
        {
            "location": "/repository/intro/#implementing-projectrepo-service",
            "text": "The  DefaultGormRepo  that is setup for the Project domain will of course not always be adequate for the business logic.\nAgain running with the \"intelligent defaults but easy to override\" mantra we can easily and selectively override the defaults in the repository. \nLets say we want to do something more advanced during the create such as validate and retrieve info from GitHub. \nIts not recomended to autowire beans into the domains for performance reasons\nIt can also be tricky and at times fairly messy trying to modify or create domains using gorm's hibernate inspired event methods.\nSuch as  beforeCreate  inside the Project domain and deal with flushing.  We can abstract out the logic into a ProjectRepo.   Lets say we wanted to use a service to validate Github repo and retrieve the description on create.\nWe can add a class to the  grails-app/repository  directory as in the following example.  package   tracker  @CompileStatic  class   ProjectRepo   implements   GormRepo Project { \n\n     @Autowired   GitHubApi   gitHubApi \n\n     //event method used to update the descriptions with the ones in github \n     void   afterCreate ( Project   project ,   Map   params ){ \n         Map   repoInfo   =   gitHubApi . getGitRepo ( params . gitHubRepo ) \n         //check that it was found using the slug or repoId \n         if   (! repoInfo )  \n             throw   new   DataRetrievalFailureException ( Github Repo is invalid for ${params.gitHubInfo} ) \n\n         if ( repoInfo . description ){ \n             //force the gitHubRepo.description to be whats in github \n             project . gitHubInfo . description   =   repoInfo . description \n             //update project.description to be the same if its null \n             project . description   =   project . description   ?:   repoInfo . description \n             project . persist ()   //optional \n         } \n     }  }  // elsewhere, you can call and it will be automatically taken care of  Project . create ( params )   Events methods and fired spring events are run inside the inherited transaction and as usual an uncaught runtime exception will rollback.\nThe  persist  methods is another addition to the domains added by the GormRepoEntity trait. In the example above its not really needed as \nthe changes will be flushed during the transaction commit. They are here to doc whats happening \nand so that validation failures can be easily seen.",
            "title": "Implementing ProjectRepo Service"
        },
        {
            "location": "/repository/intro/#testing-the-projectrepo-changes",
            "text": "class ProjectSpec extends Specification implements DomainAutoTest Project  {\nTODO\n}",
            "title": "Testing the ProjectRepo Changes"
        },
        {
            "location": "/repository/ref/",
            "text": "The Repository Artefact\n\n\nThis plugin adds a new artefact type \nRepository\n. Each domain will have a spring bean setup for it if \none doesn't exists already.\n\n\nA repository bean is configured for each domain with a \nDefaultGormRepo\n unless explicit repository class. \n\nThe trait \nGormRepo\n implements the \nRepositoryApi\n interface and is what backs the DefaultGormRepo. \nYou'll mostly use the \nGormRepo\n trait when creating a custom concrete implementation of a Repository.\n\n\nReference to a Repository for given domain class can be easily obtained by calling \nMyDomainClass.repo\n static method.\n\n\nImplementing A Repository\n\n\nIf you need to override the \nDefaultGormRepo\n that is attached to each domain then you can create your own service\ninside grails-app/repository and name it \nYourDomainNameRepo\n (eg \nOrgRepo\n). \nPlugin will automatically lookup all Repository classes and configure them as spring service beans to be used for \nyour domain.\n\n\nA Repository must either implement \nGormRepo\n Trait or if you wish extend \nDefaultGormRepo\n\n\nExample:\n\n\nclass\n \nOrgRepo\n \nimplements\n \nGormRepo\nOrg\n \n{\n\n\n    \nvoid\n \nbeforeBind\n(\nOrg\n \norg\n,\n \nMap\n \nparams\n)\n \n{\n\n       \n//do some thing before create\n\n     \n}\n\n\n\n}\n\n\n\n\n\nGormRepoEntity Trait\n\n\nSee Groovydocs api for the \nGormRepoEntity\n that is injected onto all domains.\n\n\nInstance methods added to the domains\n\n\nEvery domain gets a repository which is either setup for you or setup by implementing \n\nGormRepo\n \nEach method is transactional and will prevent incomplete cascading saves.\n\n\n\n\n\n\npersist()\n: calls the GormRepo's persist which in turn calls domain.save(failOnError:true) \n  Throws a \nDomainException\n\n\n\n\n\n\nremove()\n:  calls the GormRepo's remove. \n  Throws a \nDomainException\n\n\n\n\n\n\nStatics added to the domain\n\n\n\n\n\n\ncreate(params)\n:  calls the repo.create which does the bolier plate code you might find in a scaffolded controller. \ncreates a new instance, sets the params and calls the repository.save (essentially the persist()). \nex:\n \nBook.insertAndSave([name:'xyz',isbn:'123'])\n\nThrows a \nDomainException\n if anything goes wrong\n\n\n\n\n\n\nupdate(params)\n:  calls the repo.update which does the boiler plate code you might find in a scaffolded controller. gets the instance base in the params.id, sets the params and calls the repository.save for it. \nex:\n Book.update([id:11,name:'aaa']) Throws a \nDomainException\n if anything goes wrong\n\n\n\n\n\n\nremove(id)\n:  calls the repository.removeById gets the instance base in the params.id, calls the delete for it. \nex:\n \nBook.remove([id:11])\n\nThrows a \nDomainException\nif anything goes wrong\n\n\n\n\n\n\nrepo\n: a quick way to get to the repository for the Domain. It will return the DefaultGormRepo that was auto created \n  or one you defined for the domain under grails-app/repository.\n\n\n\n\n\n\nRepository Events\n\n\nMethods\n\n\nEach Repository can implement any of the methods listed below and they will get called during persistence operation.  \n\n\n\n\nbeforeBind(T instance, Map params)\n - Called before a new instance is saved, can be used to do custom data binding or initialize the state of domain etc.  \n\n\nafterCreate(T instance, Map params)\n - Called after the new instance is saved.  \n\n\nbeforeRemove(T instance)\n - Called before an instance is deleted. Can be utilized to cleanup related records etc.  \n\n\nafterRemove(T instance)\n - After an instance is removed.  \n\n\nbeforeUpdate(T instance, Map params)\n - Called before an instance is updated  \n\n\nafterUpdate(T instance, Map params)\n - Called after an instance is updated  \n\n\nbeforePersist(T instance)\n - Called every time before an instance is saved.  \n\n\nafterPersist(T instance)\n - Called every time after an instance is saved.\n\n\n\n\nSpring Events\n\n\nThe Repository also publishes a number of \n\nevents as listed in the Groovydoc API\n\n\nExample\n\n\nimport\n \norg.springframework.context.event.EventListener\n\n\nimport\n \ngorm.tools.repository.events.BeforeBindEvent\n\n\n\nclass\n \nOrgListener\n \n{\n\n\n    \n@EventListener\n\n    \nvoid\n \nbeforeBind\n(\nbeforeBindEvent\nOrg\n \nevent\n)\n \n{\n\n       \nOrg\n \norg\n \n=\n \nevent\n.\nentity\n\n       \n//Do some thing here.\n\n    \n}\n\n\n}\n\n\n\n\nGrails Events\n\n\nThe Repository also provides a possibility to handle events using Grails annotations. Please see docs for \nGrails Events\n.\n\n\nPublishing events\n\n\nGrails provides two ways for creating events - using \n@Publisher\n annotation on a method and using\n\nEventBus\n directly, please see docs for \nEvent Publishing\n.\nIn case of using publisher annotation Grails takes event id from the method name (method with \n@Publisher\n annotation).\nIf using \nEventBus\n we should specify event id manually.\n\n\nBy default Repository uses \nEventBus\n to create events (see \nRepoEventPublisher\n).\nIt publishes a number of \nRepository Events\n and provides it's own way to build event ids.\nAll ids of repository events correspond to the format \ndomainName\n.\neventTypeName\n.\nAs we can see there are two values separated with a dot. The first comes a name of a domain class, for which an event\nis created and the second - a type of a specific repository event. For example, in case we call \npersist()\n method\non a domain entity called \nOrg\n, the repository invokes several events, one of them is BeforePersist event with id \nOrg.beforePersist\n.\n\n\nSubscribing to events\n\n\nGrails provides several options for handling events, please see Grails docs for \nEvent Handling\n.\n\n\nIn case of adding \n@Subscriber\n annotation to a method, Grails determines event id from the method name\nby default. For example, methods like \nsomeEvent()\n or \nonSomeEvent()\n listen to the event with id \nsomeEvent\n.\n\n\nDue to the fact that ids of repository events contain \n.\n symbol, we should pass event id to the Subscriber annotation like so:\n\n\n    \n@Subscriber\n(\nSomeDomain.someEvent\n)\n\n    \nvoid\n \nsomeMethod\n()\n \n{}\n\n\n\n\n\nAccording to Grails docs, a class which contains a listener method (with \n@Subscriber\n annotation) should be a \nspring bean\n.\n\n\nPlease see the example with \nOrgSubscriber\n below:\n\n\nExample\n\n\nimport\n \ngrails.events.annotation.Subscriber\n\n\nimport\n \ngorm.tools.repository.events.BeforePersistEvent\n\n\nimport\n \ngorm.tools.repository.events.AfterPersistEvent\n\n\n\nclass\n \nOrgSubscriber\n \n{\n\n\n    \n@Subscriber\n(\nOrg.beforePersist\n)\n\n    \nvoid\n \nbeforePersist\n(\nBeforePersistEvent\n \nevent\n)\n \n{\n\n       \n// ...\n\n    \n}\n\n\n    \n@Subscriber\n(\nOrg.afterPersist\n)\n\n    \nvoid\n \nafterPersist\n(\nAfterPersistEvent\n \nevent\n)\n \n{\n\n       \n// ...\n\n    \n}\n\n\n}\n\n\n\nIn this example we can see two listeners which handle events that occur before and after\npersisting an entity of the Org domain class.\n\n\n\n\nNOTE: calling methods which trigger events inside an event listener causes an infinite loop\n\n\n\n\nUsing external groovy beans as event listeners.\n\n\nSpring dynamic languages support\n \ncan be used to register classes defined outside of application into groovy scripts as spring beans.\nWhich makes it possible to externalize the event listeners if required so.\n\n\nHere's an example.\n\n\nSomeEventListener.groovy\n outside of grails app.\n\n\n```groovy\nimport gorm.tools.repository.events.AfterRemoveEvent\nimport gorm.tools.repository.events.BeforeBindEvent\nimport org.springframework.context.event.EventListener\n\n\npublic class SomeEventListener {\n\n\n@EventListener\nvoid beforeBind(BeforeBindEvent\nOrg\n event) {\n    Org org = event.entity\n    if(event.bindAction == \nCreate\n){\n        //do something before create with event.data\n        org.event = \nCreating with data ${event.data}\n\n    } else if(event.bindAction == \nUpdate\n){\n        org.event = \nUpdating with data ${event.data}\n\n    }\n}\n\n\n\n\n\n}\n\nDefine external class a spring bean in resources.groovy\n\n File\ngrails-app/conf/spring/resources.groovy\ngroovy\n\n    File file = new File(\"path to RepoEventListener.groovy\")\n    xmlns lang: \"\nhttp://www.springframework.org/schema/lang\n\"\n\n    String beanName = GrailsNameUtils.getPropertyName(file.name.replace('.groovy', ''))\n    lang.groovy(id: beanName, 'script-source': \"file:\n\", 'refresh-check-delay': 1000)\n\n```\n\n\nSee \nexample\n \nin benchmarks project.  \n\n\nData binding using MapBinder\n\n\nPlugin comes with a \nMapBinder\n Which is used by a Repository to perform databinding.\nPlugin configures \nentityMapBinder\n as default implementation of \nMapBinder\n. \nentityMapBinder\n is similar \nto grails data binder in the sense that it uses registered value converters and fallbacks to spring ConversionService.\nHowever entityMapBinder is optimized to convert most commonly encountered property types such as Numbers and Dates \nwithout going through the converters, thus resulting in faster performance.\n\n\nExample\n\n\nclass\n \nSomeService\n \n{\n\n\n        \n@Autowired\n \n        \nMapBinder\n \nbinder\n\n\n        \nvoid\n \nfoo\n(\nMap\n \nparams\n)\n \n{\n\n           \nOrg\n \norg\n \n=\n \nnew\n \nOrg\n()\n\n           \nbinder\n.\nbind\n(\norg\n,\n \nparams\n)\n\n        \n}\n\n\n\n}\n\n\n\n\n\nUsing custom MapBinder\n\nBy default all Repositories use the default \nentityMapBinder\n for databinding. However when a Repository is explicitly \ncreated for a domain class, and if required, a custom MapBinder implementation can be used to perform databinding as per the need.\n\n\nclass\n \nCustomMapBinder\n \nimplements\n \nMapBinder\n \n{\n\n\n    \npublic\n \nT\n \nGormEntity\nT\n \nbind\n(\nGormEntity\nT\n \ntarget\n,\n \nMap\nString\n,\n \nObject\n \nsource\n,\n \nString\n \nbindMethod\n)\n \n{\n\n        \n//implement  \n\n    \n}\n\n\n    \npublic\n \nT\n \nGormEntity\nT\n \nbind\n(\nGormEntity\nT\n \ntarget\n,\n \nMap\nString\n,\n \nObject\n \nsource\n)\n \n{\n\n        \n//implement\n\n    \n}\n\n\n\n}\n\n\n\nclass\n \nOrgRepo\n \nimplements\n \nGormRepo\nOrg\n \n{\n\n\n    \n@Autowired\n\n    \nCustomMapBinder\n \nmapBinder\n\n\n    \n.........\n   \n\n}\n\n\n\n\n\nThis will make the OrgRepo use CustomMapBinder for data binding.\n\n\nRepoUtil, RepoMessage Helpers\n\n\nSee \nRepoUtil\n\n\nRepoUtil:\n\n\ncheckFound(entity, Map params,String domainClassName)\n checks does the entity exists, if not throws DomainNotFoundException with human readable error text\n\n\ncheckVersion(entity,ver)\n checks the passed in version with the version on the entity (entity.version) make sure entity.version is not greater, throws DomainException\n\n\nflush()\n flushes the session\n\n\nclear()\n clears session cache\n\n\nflushAndClear()\n flushes the session and clears the session cache\n\n\nRepoMessage contains bunch of help methods for creating text messages\n\n\nSee \nRepoMessage\n\n\nThe example below shows how to build \nsaved\n message for a domain:\n\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nid:\n100\n,\nversion:\n1\n)\n\n\n    \nMap\n \nmsg\n \n=\n \nRepoMessage\n.\nsaved\n(\nuser\n)\n\n    \nassert\n \ndefault.saved.message\n \n==\n \nmsg\n.\ncode\n \n//i18 code\n\n    \nassert\n \n100\n \n==\n \nmsg\n.\nargs\n[\n1\n]\n\n\n\n\n\nList of available messages\n\n\n\n\nsaved\n\n\nnot saved\n\n\nupdated\n\n\nnot updated\n\n\ndeleted\n\n\nnot deleted\n\n\nnotFound\n\n\noptimisticLockingFailure - Another user has updated the resource while you were editing\n\n\n\n\nGorm-tools provides its own types of exceptions to handle errors which relate to domains.\n\n\nDomainException\n\n\nSee \nDomainException\n\n\nAn extension of the default ValidationException. It is possible to pass the entity and the message map.\n\n\nDomainNotFoundException\n\n\nSee \nDomainNotFoundException\n\n\nAn extension of the DomainException to be able to handle rest request which should respond with 404 error.\n\n\nAsync batch processing support\n\n\nPlugin makes it easy to process list of batches asynchronously with transaction using \nAsyncBatchSupport\n. \n\nGparsBatchSupport\n is default implementation provided by the plugin.\n\n\nbatchSize\n - Is the batchsize used for slicing the list. The default value is obtained from \nhibernate.jdbc.batch_size\n configuration setting. However it can be explicitely passed in args as shown in below example.\n\n\npoolSize\n - Is the size of Gpars thread pool used by \nGparsBatchSupport\n. The default value can configured using \ngpars.poolsize\n. If not configured, it will use the default poolsize used by Gpars. which is available processors + 1\n\n\nExample\n:\n\nclass\n \nTestService\n \n{\n\n    \nAsyncBatchSupport\n \nasyncBatchSupport\n\n\n    \nvoid\n \ninsertBatches\n(\nList\nMap\n \nlist\n)\n \n{\n\n        \nasyncBatchSupport\n.\nparallelCollate\n([\nbatchSize:\n100\n],\n \nlist\n)\n \n{\n \nMap\n \nrecord\n,\n \nMap\n \nargs\n \n-\n\n            \nOrg\n.\ncreate\n(\nrecord\n)\n\n        \n}\n\n    \n}\n\n\n\n}\n\n\n\n\nThe above code snippet will slice the list into batches of 100 and run each batch in parallel and wrap it in transaction. \n\n\nThe list can be processed in parallel without it being wrapped in transaction using \nasyncBatchSupport.parallel\n method.\n\n\nasyncBatchSupport\n.\nparallel\n(\nasyncBatchSupport\n.\ncollate\n(\nlist\n))\n \n{\n \nList\n \nbatch\n,\n \nMap\n \nargs\n \n-\n\n    \n//do some thing with the batch.\n\n\n}\n\n\n\n\n\nTesting support\n\n\nPlugin provides \nGormToolsTest\n and \nGormToolsHibernateSpec\n\nTo make it easy to write tests which utilizes repository.\n\n\nWriting unit tests using GormToolsTest\n\nGormToolsTest extends grails DataTest and configures a repository bean for every mock domain.\n\nThe repository class must exist in same package as the domain class, or else, it will configure \nDefaultGormRepo as the repository for the given domain.\n\n\nclass\n \nCitySpec\n \nextends\n \nSpecification\n \nimplements\n \nGormToolsTest\n \n{\n\n\n   \nvoid\n \nsetup\n()\n \n{\n\n     \nmockDomain\n(\nCity\n)\n\n   \n}\n\n\n   \nvoid\n \ntest create\n()\n \n{\n\n     \ngiven:\n\n     \nMap\n \nparams\n \n=\n \n[\nname:\nChicago\n]\n\n\n     \nwhen:\n\n     \nCity\n \ncity\n \n=\n \nCity\n.\ncreate\n(\nparams\n)\n\n     \ngormtools\n\n\n     \nthen:\n\n     \ncity\n.\nname\n \n==\n \nChicago\n\n   \n}\n\n\n}\n\n\n\n\n\nGormToolsHibernateSpec\n\nGormToolsHibernateSpec extends HibernateSpec and setups repository beans for domains. \nCan be used to unit test with full hibernate support with inmemory database.\n\n\nclass\n \nCitySpec\n \nextends\n \nGormToolsHibernateSpec\n \n{\n\n\n  \nList\nClass\n \ngetDomainClasses\n()\n \n{\n \n[\nCity\n]\n \n}\n\n\n   \nvoid\n \ntest create\n()\n \n{\n\n     \ngiven:\n\n     \nMap\n \nparams\n \n=\n \n[\nname:\nChicago\n]\n\n\n     \nwhen:\n\n     \nCity\n \ncity\n \n=\n \nCity\n.\ncreate\n(\nparams\n)\n\n     \n//or City.repo.create(params)\n\n\n     \nthen:\n\n     \ncity\n.\nname\n \n==\n \nChicago\n\n   \n}\n\n\n}\n\n\n\n\n\nWhen \ngetDomainClasses()\n is overridden GormToolsHibernateSpec will try to find the repository in the same package as domain class. \nAlternatively if \ngetPackageToScan()\n is provided, it will find all the repository from the given package and below it.",
            "title": "Reference"
        },
        {
            "location": "/repository/ref/#the-repository-artefact",
            "text": "This plugin adds a new artefact type  Repository . Each domain will have a spring bean setup for it if \none doesn't exists already.  A repository bean is configured for each domain with a  DefaultGormRepo  unless explicit repository class.  \nThe trait  GormRepo  implements the  RepositoryApi  interface and is what backs the DefaultGormRepo. \nYou'll mostly use the  GormRepo  trait when creating a custom concrete implementation of a Repository.  Reference to a Repository for given domain class can be easily obtained by calling  MyDomainClass.repo  static method.",
            "title": "The Repository Artefact"
        },
        {
            "location": "/repository/ref/#implementing-a-repository",
            "text": "If you need to override the  DefaultGormRepo  that is attached to each domain then you can create your own service\ninside grails-app/repository and name it  YourDomainNameRepo  (eg  OrgRepo ). \nPlugin will automatically lookup all Repository classes and configure them as spring service beans to be used for \nyour domain.  A Repository must either implement  GormRepo  Trait or if you wish extend  DefaultGormRepo  Example:  class   OrgRepo   implements   GormRepo Org   { \n\n     void   beforeBind ( Org   org ,   Map   params )   { \n        //do some thing before create \n      }  }",
            "title": "Implementing A Repository"
        },
        {
            "location": "/repository/ref/#gormrepoentity-trait",
            "text": "See Groovydocs api for the  GormRepoEntity  that is injected onto all domains.",
            "title": "GormRepoEntity Trait"
        },
        {
            "location": "/repository/ref/#instance-methods-added-to-the-domains",
            "text": "Every domain gets a repository which is either setup for you or setup by implementing  GormRepo  \nEach method is transactional and will prevent incomplete cascading saves.    persist() : calls the GormRepo's persist which in turn calls domain.save(failOnError:true) \n  Throws a  DomainException    remove() :  calls the GormRepo's remove. \n  Throws a  DomainException",
            "title": "Instance methods added to the domains"
        },
        {
            "location": "/repository/ref/#statics-added-to-the-domain",
            "text": "create(params) :  calls the repo.create which does the bolier plate code you might find in a scaffolded controller. \ncreates a new instance, sets the params and calls the repository.save (essentially the persist()).  ex:   Book.insertAndSave([name:'xyz',isbn:'123']) \nThrows a  DomainException  if anything goes wrong    update(params) :  calls the repo.update which does the boiler plate code you might find in a scaffolded controller. gets the instance base in the params.id, sets the params and calls the repository.save for it.  ex:  Book.update([id:11,name:'aaa']) Throws a  DomainException  if anything goes wrong    remove(id) :  calls the repository.removeById gets the instance base in the params.id, calls the delete for it.  ex:   Book.remove([id:11]) \nThrows a  DomainException if anything goes wrong    repo : a quick way to get to the repository for the Domain. It will return the DefaultGormRepo that was auto created \n  or one you defined for the domain under grails-app/repository.",
            "title": "Statics added to the domain"
        },
        {
            "location": "/repository/ref/#repository-events",
            "text": "",
            "title": "Repository Events"
        },
        {
            "location": "/repository/ref/#methods",
            "text": "Each Repository can implement any of the methods listed below and they will get called during persistence operation.     beforeBind(T instance, Map params)  - Called before a new instance is saved, can be used to do custom data binding or initialize the state of domain etc.    afterCreate(T instance, Map params)  - Called after the new instance is saved.    beforeRemove(T instance)  - Called before an instance is deleted. Can be utilized to cleanup related records etc.    afterRemove(T instance)  - After an instance is removed.    beforeUpdate(T instance, Map params)  - Called before an instance is updated    afterUpdate(T instance, Map params)  - Called after an instance is updated    beforePersist(T instance)  - Called every time before an instance is saved.    afterPersist(T instance)  - Called every time after an instance is saved.",
            "title": "Methods"
        },
        {
            "location": "/repository/ref/#spring-events",
            "text": "The Repository also publishes a number of  events as listed in the Groovydoc API  Example  import   org.springframework.context.event.EventListener  import   gorm.tools.repository.events.BeforeBindEvent  class   OrgListener   { \n\n     @EventListener \n     void   beforeBind ( beforeBindEvent Org   event )   { \n        Org   org   =   event . entity \n        //Do some thing here. \n     }  }",
            "title": "Spring Events"
        },
        {
            "location": "/repository/ref/#grails-events",
            "text": "The Repository also provides a possibility to handle events using Grails annotations. Please see docs for  Grails Events .",
            "title": "Grails Events"
        },
        {
            "location": "/repository/ref/#publishing-events",
            "text": "Grails provides two ways for creating events - using  @Publisher  annotation on a method and using EventBus  directly, please see docs for  Event Publishing .\nIn case of using publisher annotation Grails takes event id from the method name (method with  @Publisher  annotation).\nIf using  EventBus  we should specify event id manually.  By default Repository uses  EventBus  to create events (see  RepoEventPublisher ).\nIt publishes a number of  Repository Events  and provides it's own way to build event ids.\nAll ids of repository events correspond to the format  domainName . eventTypeName .\nAs we can see there are two values separated with a dot. The first comes a name of a domain class, for which an event\nis created and the second - a type of a specific repository event. For example, in case we call  persist()  method\non a domain entity called  Org , the repository invokes several events, one of them is BeforePersist event with id  Org.beforePersist .",
            "title": "Publishing events"
        },
        {
            "location": "/repository/ref/#subscribing-to-events",
            "text": "Grails provides several options for handling events, please see Grails docs for  Event Handling .  In case of adding  @Subscriber  annotation to a method, Grails determines event id from the method name\nby default. For example, methods like  someEvent()  or  onSomeEvent()  listen to the event with id  someEvent .  Due to the fact that ids of repository events contain  .  symbol, we should pass event id to the Subscriber annotation like so:       @Subscriber ( SomeDomain.someEvent ) \n     void   someMethod ()   {}   According to Grails docs, a class which contains a listener method (with  @Subscriber  annotation) should be a  spring bean .  Please see the example with  OrgSubscriber  below:  Example  import   grails.events.annotation.Subscriber  import   gorm.tools.repository.events.BeforePersistEvent  import   gorm.tools.repository.events.AfterPersistEvent  class   OrgSubscriber   { \n\n     @Subscriber ( Org.beforePersist ) \n     void   beforePersist ( BeforePersistEvent   event )   { \n        // ... \n     } \n\n     @Subscriber ( Org.afterPersist ) \n     void   afterPersist ( AfterPersistEvent   event )   { \n        // ... \n     }  }  \nIn this example we can see two listeners which handle events that occur before and after\npersisting an entity of the Org domain class.   NOTE: calling methods which trigger events inside an event listener causes an infinite loop",
            "title": "Subscribing to events"
        },
        {
            "location": "/repository/ref/#using-external-groovy-beans-as-event-listeners",
            "text": "Spring dynamic languages support  \ncan be used to register classes defined outside of application into groovy scripts as spring beans.\nWhich makes it possible to externalize the event listeners if required so.  Here's an example.  SomeEventListener.groovy  outside of grails app.  ```groovy\nimport gorm.tools.repository.events.AfterRemoveEvent\nimport gorm.tools.repository.events.BeforeBindEvent\nimport org.springframework.context.event.EventListener  public class SomeEventListener {  @EventListener\nvoid beforeBind(BeforeBindEvent Org  event) {\n    Org org = event.entity\n    if(event.bindAction ==  Create ){\n        //do something before create with event.data\n        org.event =  Creating with data ${event.data} \n    } else if(event.bindAction ==  Update ){\n        org.event =  Updating with data ${event.data} \n    }\n}  } Define external class a spring bean in resources.groovy\n\n File grails-app/conf/spring/resources.groovy groovy\n\n    File file = new File(\"path to RepoEventListener.groovy\")\n    xmlns lang: \" http://www.springframework.org/schema/lang \"\n\n    String beanName = GrailsNameUtils.getPropertyName(file.name.replace('.groovy', ''))\n    lang.groovy(id: beanName, 'script-source': \"file: \", 'refresh-check-delay': 1000)\n\n```  See  example  \nin benchmarks project.",
            "title": "Using external groovy beans as event listeners."
        },
        {
            "location": "/repository/ref/#data-binding-using-mapbinder",
            "text": "Plugin comes with a  MapBinder  Which is used by a Repository to perform databinding.\nPlugin configures  entityMapBinder  as default implementation of  MapBinder .  entityMapBinder  is similar \nto grails data binder in the sense that it uses registered value converters and fallbacks to spring ConversionService.\nHowever entityMapBinder is optimized to convert most commonly encountered property types such as Numbers and Dates \nwithout going through the converters, thus resulting in faster performance.  Example  class   SomeService   { \n\n         @Autowired  \n         MapBinder   binder \n\n         void   foo ( Map   params )   { \n            Org   org   =   new   Org () \n            binder . bind ( org ,   params ) \n         }  }   Using custom MapBinder \nBy default all Repositories use the default  entityMapBinder  for databinding. However when a Repository is explicitly \ncreated for a domain class, and if required, a custom MapBinder implementation can be used to perform databinding as per the need.  class   CustomMapBinder   implements   MapBinder   { \n\n     public   T   GormEntity T   bind ( GormEntity T   target ,   Map String ,   Object   source ,   String   bindMethod )   { \n         //implement   \n     } \n\n     public   T   GormEntity T   bind ( GormEntity T   target ,   Map String ,   Object   source )   { \n         //implement \n     }  }  class   OrgRepo   implements   GormRepo Org   { \n\n     @Autowired \n     CustomMapBinder   mapBinder \n\n     .........     }   This will make the OrgRepo use CustomMapBinder for data binding.",
            "title": "Data binding using MapBinder"
        },
        {
            "location": "/repository/ref/#repoutil-repomessage-helpers",
            "text": "See  RepoUtil",
            "title": "RepoUtil, RepoMessage Helpers"
        },
        {
            "location": "/repository/ref/#repoutil",
            "text": "checkFound(entity, Map params,String domainClassName)  checks does the entity exists, if not throws DomainNotFoundException with human readable error text  checkVersion(entity,ver)  checks the passed in version with the version on the entity (entity.version) make sure entity.version is not greater, throws DomainException  flush()  flushes the session  clear()  clears session cache  flushAndClear()  flushes the session and clears the session cache",
            "title": "RepoUtil:"
        },
        {
            "location": "/repository/ref/#repomessage-contains-bunch-of-help-methods-for-creating-text-messages",
            "text": "See  RepoMessage  The example below shows how to build  saved  message for a domain:       User   user   =   new   User ( id: 100 , version: 1 ) \n\n     Map   msg   =   RepoMessage . saved ( user ) \n     assert   default.saved.message   ==   msg . code   //i18 code \n     assert   100   ==   msg . args [ 1 ]   List of available messages   saved  not saved  updated  not updated  deleted  not deleted  notFound  optimisticLockingFailure - Another user has updated the resource while you were editing   Gorm-tools provides its own types of exceptions to handle errors which relate to domains.",
            "title": "RepoMessage contains bunch of help methods for creating text messages"
        },
        {
            "location": "/repository/ref/#domainexception",
            "text": "See  DomainException  An extension of the default ValidationException. It is possible to pass the entity and the message map.",
            "title": "DomainException"
        },
        {
            "location": "/repository/ref/#domainnotfoundexception",
            "text": "See  DomainNotFoundException  An extension of the DomainException to be able to handle rest request which should respond with 404 error.",
            "title": "DomainNotFoundException"
        },
        {
            "location": "/repository/ref/#async-batch-processing-support",
            "text": "Plugin makes it easy to process list of batches asynchronously with transaction using  AsyncBatchSupport .  GparsBatchSupport  is default implementation provided by the plugin.  batchSize  - Is the batchsize used for slicing the list. The default value is obtained from  hibernate.jdbc.batch_size  configuration setting. However it can be explicitely passed in args as shown in below example.  poolSize  - Is the size of Gpars thread pool used by  GparsBatchSupport . The default value can configured using  gpars.poolsize . If not configured, it will use the default poolsize used by Gpars. which is available processors + 1  Example : class   TestService   { \n     AsyncBatchSupport   asyncBatchSupport \n\n     void   insertBatches ( List Map   list )   { \n         asyncBatchSupport . parallelCollate ([ batchSize: 100 ],   list )   {   Map   record ,   Map   args   - \n             Org . create ( record ) \n         } \n     }  }   The above code snippet will slice the list into batches of 100 and run each batch in parallel and wrap it in transaction.   The list can be processed in parallel without it being wrapped in transaction using  asyncBatchSupport.parallel  method.  asyncBatchSupport . parallel ( asyncBatchSupport . collate ( list ))   {   List   batch ,   Map   args   - \n     //do some thing with the batch.  }",
            "title": "Async batch processing support"
        },
        {
            "location": "/repository/ref/#testing-support",
            "text": "Plugin provides  GormToolsTest  and  GormToolsHibernateSpec \nTo make it easy to write tests which utilizes repository.  Writing unit tests using GormToolsTest \nGormToolsTest extends grails DataTest and configures a repository bean for every mock domain. \nThe repository class must exist in same package as the domain class, or else, it will configure \nDefaultGormRepo as the repository for the given domain.  class   CitySpec   extends   Specification   implements   GormToolsTest   { \n\n    void   setup ()   { \n      mockDomain ( City ) \n    } \n\n    void   test create ()   { \n      given: \n      Map   params   =   [ name: Chicago ] \n\n      when: \n      City   city   =   City . create ( params ) \n      gormtools \n\n      then: \n      city . name   ==   Chicago \n    }  }   GormToolsHibernateSpec \nGormToolsHibernateSpec extends HibernateSpec and setups repository beans for domains. \nCan be used to unit test with full hibernate support with inmemory database.  class   CitySpec   extends   GormToolsHibernateSpec   { \n\n   List Class   getDomainClasses ()   {   [ City ]   } \n\n    void   test create ()   { \n      given: \n      Map   params   =   [ name: Chicago ] \n\n      when: \n      City   city   =   City . create ( params ) \n      //or City.repo.create(params) \n\n      then: \n      city . name   ==   Chicago \n    }  }   When  getDomainClasses()  is overridden GormToolsHibernateSpec will try to find the repository in the same package as domain class. \nAlternatively if  getPackageToScan()  is provided, it will find all the repository from the given package and below it.",
            "title": "Testing support"
        },
        {
            "location": "/queries-mango/",
            "text": "Gorm-tools provides a convenient way for iterating over records which correspond to a given SQL query.\n\n\nMango Overview\n\n\nThe primary motive here is to create an easy dynamic way to query via a rest api or using a simple map.\nThe repository comes with a \nquery(criteriaMap, closure)\n method. It allows to get paged list of entities restricted by\nthe properties in the \ncriteriaMap\n. The map could be passed as JSON string or Map. All restrictions should be under \n\ncriteria\n keyword by default, but it can be changed with \nconfig\n.\n\n\nAnything in the optional closure will be passed into Gorm/Hibernate criteria closure\n\n\n\n\nA lot of inspiration was drawn from \nRestdb.io\n\n\nthe query language is similar to \nMongo's\n\n\nand CouchDB's new \nMango selector-syntax\n.\n\n\nAlso inspired by \njson-sql\n\n\n\n\n\n\n \nWhilst selectors have many similarities with MongoDB query documents, \nthese arise more from a similarity of purpose and do not necessarily extend to commonality of function or result.\n\n\n\n\nBasic example\n\n\nOrg\n.\nrepo\n.\nquery\n([\n\n  \ncriteria\n:\n \n[\nname\n:\n \nBill%\n,\n \ntype\n:\n \nNew\n],\n\n  \nsort\n:\n \n[\nname\n:\nasc\n],\n\n  \nmax\n:\n \n20\n\n\n]){\n\n  \ngt\n \nid\n,\n \n5\n\n\n}\n\n\n\n\n\nThe same result can be reached with criteria:\n\n\nCriteria\n \ncriteria\n \n=\n \nOrg\n.\ncreateCriteria\n()\n\n\ncriteria\n.\nlist\n(\nmax\n:\n \n20\n)\n \n{\n\n    \nilike\n \nname\n,\n \nBill%\n\n    \neq\n \ntype\n,\n \nNew\n\n    \ngt\n \nid\n,\n \n5\n\n    \norder\n(\nname\n,\n \nasc\n)\n\n\n}\n\n\n\n\n\nRestful API query\n\n\nSee the docs here for more examples and info \nhttps://yakworks.github.io/gorm-rest-api/\n\n\nMango QL\n\n\nThe Mango query language is similar to \nMongo's\n\nand CouchDB's new \nMango selector-syntax\n\nwith some inspiration from \njson-sql\n as well\n\n\nLogical\n\n\n\n\n\n\n\n\nOp\n\n\nDescription\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\n$and\n\n\ndefault\n\n\n$and: [ {\nname\n: \nBelak\n}, {\nstatus\n: \nD\n} ]\n \n equivalent to \nname\n: \nBelak\n, \nstatus\n: \nD\n\n\n\n\n\n\n$or\n\n\n\"ors\" them all\n\n\n$or: [ {\nname\n: \nBelak\n}, {\nfork\n: true} ]\n \n \n$or: {\nname\n: \nBelak\n, \nfork\n: true }\n\n\n\n\n\n\n$not\n\n\nALL not equal, !=, \n\n\n$not:{ \nstatus\n: \nDestroyed\n, \ndateStatus\n: \n2371\n }\n\n\n\n\n\n\n$nor\n\n\nANY one is not equal\n\n\n$nor:{ \nname\n: \nRomulan\n, \nfork\n: 12\n}\n\n\n\n\n\n\n\n\nComparison\n\n\n\n\n\n\n\n\nOp\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n$gt\n\n\n  greater than\n\n\ncargo\n: {\n$gt\n: 10000}\n\n\n\n\n\n\n$gte\n\n\n= greater than or equal\n\n\ncargo\n: {\n$gte\n: 10000}\n\n\n\n\n\n\n$lt\n\n\n  less than\n\n\ncargo\n: {\n$lt\n: 10000}\n\n\n\n\n\n\n$lte\n\n\n= less than or equal\n\n\ncargo\n: {\n$lte\n: 10000}\n\n\n\n\n\n\n$between\n\n\nbetween two distinct values\n\n\ndateStatus\n: {\n$between\n: [2300, 2400]}\n\n\n\n\n\n\n$like\n\n\nlike expression\n\n\nname\n: {\n$like\n: \nRom%\n}\n\n\n\n\n\n\n$ilike\n\n\nlike auto-append %\n\n\nname\n: {\n$ilike\n: \nrom\n}\n\n\n\n\n\n\n$eq\n\n\n= equal, concieince for builders\n\n\nsalary\n: {\n$eq\n: 10}\n | \nsalary\n: 10\n\n\n\n\n\n\n$ne\n\n\nnot equal, !=, \n\n\nage\n : {\n$ne\n : 12}}\n\n\n\n\n\n\n$in\n\n\nMatch any value in array\n\n\nfield\n : {\n$in\n : [value1, value2, ...]\n\n\n\n\n\n\n$nin\n\n\nNot match any value in array\n\n\nfield\n : {\n$nin\n : [value1, value2, ...]}\n\n\n\n\n\n\n$isNull\n\n\nValue is null\n\n\nname\n: \n$isNull\n \\|\n\"name\": null\n\n\n\n\n\n\n$isNotNull\n\n\nValue is not null\n\n\nname\n: \n$isNotNull\n \\|\n\"name\":{$ne: null}\n\n\n\n\n\n\n\n\nFields\n\n\n\n\n\n\n\n\nOp\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n$gtf\n\n\n  another field\n\n\ncargo\n: {\n$gtf\n: \nmaxCargo\n}\n\n\n\n\n\n\n$gtef\n\n\n= field\n\n\ncargo\n: {\n$gtef\n: \nmaxCargo\n}\n\n\n\n\n\n\n$ltf\n\n\n  field\n\n\ncargo\n: {\n$ltf\n: \nmaxCargo\n}\n\n\n\n\n\n\n$ltef\n\n\n= field\n\n\ncargo\n: {\n$ltef\n: \nmaxCargo\n}\n\n\n\n\n\n\n$eqf\n\n\n= field\n\n\ncargo\n: {\n$eqf\n: \ncontrolTotal\n}\n\n\n\n\n\n\n$nef\n\n\nnot equal, !=, \n\n\ncargo\n : {\n$nef\n : \ncontrolTotal\n}}\n\n\n\n\n\n\n\n\nConvert to Mango QL\n\n\nThe \nMangoTidyMap utility\n\ntransforms parameters map to Mango QL criteria map. \nHere is several examples of usage:\n\n\nassert\n \nMangoTidyMap\n.\ntidy\n([\na\n:\n5\n])\n \n==\n \n[\na\n:[\n$eq\n:\n5\n]]\n\n\nassert\n \nMangoTidyMap\n.\ntidy\n([\nb\n:\nBill%\n])\n \n==\n \n[\nb\n:[\n$ilike\n:\n5\n]]\n\n\nassert\n \nMangoTidyMap\n.\ntidy\n([\nc\n:\n \n[\n1\n,\n2\n,\n3\n]])\n \n==\n \n[\nc\n:[\n$in\n:[\n1\n,\n2\n,\n3\n]]]\n\n\n\n\n\nOne of the useful features of the MangoTidyMap is that it converts path to nested map which is required by \nmangoQuery\n\n\nassert\n \nMangoTidyMap\n.\ntidy\n[\na\n.\nb\n.\nc\n:\n \n3\n])\n \n==\n \n[\na\n:[\nb\n:[\nc\n:[\n$eq\n:\n3\n]]]]\n\n\n\nFor more example take a look on \nMangoTidyMapSpec\n \n\n\nMango query\n\n\nThe repository by default does not have all the features of mango service, just \nbuildCriteria\n and \nquery\n methods, but both automatically\nconvert map params to mango map, so just \nparams\n or \nrequest.JSON\n can be passed. \n\n\nSee \nMango Api\n to know all features that are provided.\n\n\nExamples\n\n\nBellow will be a list of supported syntax for params in json format, which is supported:\nAssume we are running these on star trek characters \nhttp://stapi.co/api/v1/rest/character?uid=CHMA0000128908\n\n\n{\n\n  \ncriteria\n:\n \n{\n\n    \nname\n:\n \nKira%\n,\n \n/* if it ends with % then it will us an ilike */\n\n    \ngender\n:\n \nF\n,\n \n//no % its straight up\n\n    \nplaceOfBirth\n:\n \n{\n$ilike\n:\n \nbajor%\n},\n \n/* a case-insensitive \nlike\n expression appends the % */\n\n    \nhologram\n:\n \ntrue\n,\n \n/* boolean */\n\n    \ncreatedDate\n:\n \n1993-05-16T00:00:00.000Z\n,\n \n// dates\n\n    \ndateOfBirth\n:\n \n1957-07-26\n \n// dates\n\n    \nplaceOfBirth\n:\n \n{\n$eqf\n:\n \n$placeOfDeath\n}\n \n//equals another field in set\n\n  \n},\n\n  \nsort\n:\nname\n \n// asc by default\n\n\n}\n\n\n\n\n\nThis would produce in a round about way with criteria builders a where clause like this\n\n\n  \n..\n \nname\n \nlike\n \nKira%\n \nAND\n \ngender\n=\nF\n \nAND\n \nplaceOfBirth\n \nlike\n \nbajor%\n \nAND\n \nhologram\n \n=\n \ntrue\n\n  \nAND\n \ncreatedDate\n \n=\n \n???\n \nAND\n \ndateOfBirth\n \n=\n \n???\n \nAND\n \nplaceOfBirth\n \n=\n \nplaceOfDeath\n\n  \nORDER\n \nBY\n \nname\n \nASC\n,\n \ndateOfBirth\n \nDESC\n;\n\n\n\n\n\nAssociations\n\n\n{\n\n  \ncriteria\n:\n \n{\n\n    \ncustomer.id\n:\n \n101\n,\n\n    \ncustomerId\n:\n \n101\n,\n \n/* check if domain has customerId property, if not then uses customer.id 101 above */\n\n    \ncustomer\n:\n \n{\n \n/* nested object way */\n\n      \nid\n:\n \n101\n,\n\n      \nname\n:\n \nWal%\n\n    \n}\n\n  \n}\n\n  \nsort\n:\n \n{\n\n    \ncustomer.name\n:\n \nasc\n,\n\n    \ntranDate\n:\n \ndesc\n\n  \n}\n\n\n}\n\n\n\n\n\nIN Clause\n\n\n{\n\n  \ncriteria\n:\n \n{\n\n    \ncustomer.id\n:\n \n[\n101\n,\n102\n,\n103\n],\n \n/* an array means it will use in/inList */\n\n    \ncustomer\n:\n \n[{\nid\n:\n101\n},{\nid\n:\n102\n},{\nid\n:\n103\n}],\n \n//can be in summarized object form as well\n\n    \ncustomer.id\n:\n \n[\n101\n,\n102\n,\n103\n],\n \n/* an array means it will use in/inList */\n\n    \n//the 3 above are different ways to do this\n\n    \ncustomer.id\n:\n \n{\n$in\n:\n \n[\n101\n,\n102\n,\n103\n]},\n\n    \ncustomer\n:\n \n{\n\n      \nid\n:\n \n{\n$in\n:\n \n[\n101\n,\n102\n,\n103\n]}\n\n    \n},\n\n\n    \ncustomer.id\n:\n \n{\n$nin\n:\n \n[\n101\n,\n102\n,\n103\n]},\n \n/* an array means it will use `not { in/inList }`*/\n\n  \n}\n\n\n}\n\n\n\n\n\nFields Comparison Examples\n\n\n  \namount\n:\n \n{\n$ne\n:\n \n50\n},\n \n/*not equal*/\n\n  \namount\n:\n \n{\n$gt\n:\n \n100\n},\n \n/* greater than value */\n\n  \namount.$gt\n:\n \n100\n \n/* another form of the above one, can be useful when json is build, for example from angular model, where  you can\nt right in object form*/\n\n  \namount\n:\n \n{\n$ge\n:\n \n100\n},\n \n/* greater or equal than value */\n\n\n  \namount\n:\n \n{\n$lt\n:\n \n$origAmount\n},\n \n/* less than value of another field*/\n\n  \namount\n:\n \n{\n$le\n:\n \n$origAmount\n},\n \n/* less or equal than value */\n\n\n  \namount\n:\n{\n \n//all these will get anded together\n\n    \n$gt\n:\n \n5.0\n,\n\n    \n$lt\n:\n \n15.50\n,\n\n    \n$ne\n:\n \n9.99\n\n  \n},\n\n\n  \namount\n:\n \n{\n$between\n:\n \n[\n0\n,\n100\n]},\n \n/* between value */\n\n\n  \nstatus\n:\n \n$isNull\n \n/* translates to isNull*/\n\n  \nstatus\n:\n \n{\n$isNull\n:\n \ntrue\n},\n \n/* translates to isNull*/\n\n  \nstatus\n:\n \n{\n$isNull\n:\n \nfalse\n},\n \n/* translates to not{ isNull}*/\n\n  \nstatus\n:\n \nnull\n \n/* translates to isNull*/\n\n\n\n\n\nLogical operators\n\n\n    \n$or\n:\n \n{\n \n// if a single or then it can be done like this\n\n      \ncustomer.name\n:\n{\n$ilike\n:\n \nwal\n},\n\n      \ncustomer.num\n:\n{\n$ilike\n:\n \nwal\n}\n\n    \n},\n\n    \n$and\n:\n[\n \n// multiple ors would need to look like this in an array. only one and can be present too\n\n      \n{\n\n        \n$or\n:\n \n{\n\n          \ncustomer.name\n:\n \nJohn\n,\n\n          \ncustomer.name\n:\n \nJon\n\n        \n}\n\n      \n},\n\n      \n{\n\n        \n$or\n:\n \n{\n\n          \ncustomer.name\n:\n \nMark\n,\n\n          \ncustomer.name\n:\n \nMarc\n\n        \n}\n\n      \n}\n\n    \n],\n \n/* this would end up generating `.... and ( (customer.name = \nJohn\n or customer.name = \nJon\n)\n\n\n          AND (customer.name = \nMark\n or customer.name = \nMark\n) ) ....` */\n\n\n    \n$or\n:\n[\n \n// again you can only have one of these\n\n      \n{\n \n// the and is default and optional and this accomplishes the same thing as example sbelow\n\n        \ncustomer.name\n:\n \nMark\n,\n\n        \n$or\n:\n \n{\n\n          \ncustomer.sales\n:\n \n{\n$lt\n:\n \n10\n},\n\n          \ncustomer.sales\n:\n \n$isNull\n\n        \n}\n\n      \n},\n\n      \n{\n\n        \n$and\n:\n \n{\n \n//the and can be explicitly specified too if you wish\n\n          \ncustomer.name\n:\n \nJim\n,\n\n          \ncustomer.sales\n:\n \n{\n$lt\n:\n \n15\n}\n\n        \n}\n\n      \n},\n\n    \n],\n \n/* this would end up generating\n\n\n        ....\n\n\n        AND\n\n\n        (\n\n\n          (customer.name = \nmark\n and ( customer.sales \n 10 or customer.sales IS NULL))\n\n\n          OR\n\n\n          (customer.name = \njim\n and customer.sales \n 15 )\n\n\n        )\n\n\n        .... */\n\n  \n}\n\n\n}\n\n\n\n\n\nQuick Search\n\n\nQuick search - ability to search by one string in criteria filters against several domain fields, the value for quick\nsearch can be passed in \n$quickSearch\n or \n$q\n keywords. \nThere are 2 ways to specify fields that should be searched against:\n1. in static property \nquickSearchFields\n as list of strings, see example bellow:\n\n\nclass\n \nOrg\n \n{\n\n    \nString\n \nname\n\n    \nAddress\n \naddress\n\n\n    \nstatic\n \nquickSearchFields\n \n=\n \n[\nname\n,\n \naddress.city\n]\n\n    \n...\n\n\n\n1. default fields in config\n\n\ngorm\n:\n\n    \ntools\n:\n\n        \nmango\n:\n\n            \ndefaultQuickSearch\n:\n\n              \n-\n \nname\n\n              \n-\n \nnum\n\n              \n-\n \naddress.city\n\n\n\n\n\nOn application start for all domains that doesn't have a \nquickSearchFields\n property, the fields from \ndefaultQuickSearch\n\nthat each domain contains will be added. \n\n\nSo Mango criteria will add \n%\n automatically, if quick search string doesn't have it and will apply \nilike\n statement\nfor each field in \nquickSearchFields\n. If domain field is not string type, then \neq\n statement will be used.\n\n\nOrg\n.\nrepo\n.\nsearch\n([\ncriteria:\n \n[\n$quickSearch\n:\n \nabc\n],\n \nmax:\n \n20\n])\n\n\n\nSo it is the same as:\n\n\nCriteria\n \ncriteria\n \n=\n \nOrg\n.\ncreateCriteria\n()\n\n\ncriteria\n.\nlist\n(\nmax:\n \n20\n)\n \n{\n\n    \nor\n \n{\n\n        \nilike\n \nname\n,\n \nabc%\n\n        \nilike\n \naddress.city\n,\n \nabc%\n\n    \n}\n\n\n}\n\n\n\n\n\nConfiguration\n\n\nThe default \ncriteria\n keyword for the restriction map can be changed in config:\n\ngorm:\n    tools:\n        mango:\n            criteriaKeyName: filters\n\n\n\nWith such configuration restrictions for Mango criteria should be under \nfilters\n keyword.\n\n\nMango API\n\n\nMango in the Repository\n\n\nThe Repository\n implements \nMangoQueryRepo\n Trait\nwhich contains implementation for two query methods:\n\n\nDetachedCriteria\n \nbuildCriteria\n(\n \nMap\n \nparams\n=[:],\n \nClosure\n \nclosure\n=\nnull\n)\n \n{\n\n        \nmangoQuery\n.\nbuildCriteria\n(\ngetDomainClass\n(),\n \nparams\n,\n \nclosure\n)\n\n    \n}\n\n\n\nsee docs for \nDetachedCriteria\n\n\n \nList\n \nquery\n(\nMap\n \nparams\n=[:],\n \nClosure\n \nclosure\n=\nnull\n){\n\n         \nmangoQuery\n.\nquery\n(\ngetDomainClass\n(),\n \nparams\n,\n \nclosure\n)\n\n     \n}\n\n\n\nreturns list of entities with pagination. For pagination take a look at \nPager\n\n\nIf one need to override mango bean for a certain repo it can be achieved in two ways:\n\n\n\n\n\n\nimplement \ngetMangoQuery()\n method that should return instance of the class that implements \nMangoQueryApi.trait\n\n\n\n\n\n\nregister a new bean for custom criteria, and set it for the repo with \n@Qualifier\n annotation\n\n\n\n\n\n\nbeans\n \n=\n \n{\n\n    \nnewMangoQuery\n(\nNewMangoQuery\n)\n \n\n}\n\n\n\n\n\nclass\n \nNewMangoQuery\n \nimplements\n \nMangoQueryApi\n \n{\n\n\n    \n@Override\n\n    \nDetachedCriteria\n \nbuildCriteria\n(\nClass\n \ndomainClass\n,\n \nMap\n \nparams\n,\n \nClosure\n \nclosure\n \n=\n \nnull\n)\n \n{\n\n       \nreturn\n \nnull\n\n    \n}\n\n\n    \n@Override\n\n    \nList\n \nquery\n(\nClass\n \ndomainClass\n,\n \nMap\n \nparams\n,\n \nClosure\n \nclosure\n \n=\n \nnull\n)\n \n{\n\n       \nreturn\n \n[]\n\n    \n}\n\n\n}\n\n\n\n\n\nclass\n \nCityRepo\n \nextends\n \nDefaultGormRepo\nCity\n \n{\n\n\n    \n@Autowired\n\n    \n@Qualifier\n(\nnewMangoQuery\n)\n\n    \nNewMangoQuery\n \nmangoQuery\n\n\n}\n\n\n\n\n\nBuild Mango criteria\n\n\nUnder the hood Mango uses \nDetachedCriteria\n take a look on main \nbuild method\n\nOne can see that it normalizes params map to make it Mango QL and then adds restrictions to detached criteria based on map,\nif closure is passed then applies it too. \n\n\nCount totals\n\n\nIf one needs to compute totals for some fields, \nMangoQuery\n \nhas \ncountTotals\n method. Restrictions for it are working in the same way as for query method, so it can be specified \nwith params map and criteria closure.\n\n\nBut the repository beans don't contain this method, so one can call it on mangoQuery bean.\nTo specify what fields sums should be computed for, the list with fields name should be passed.\nSee example:\n\nOrg\n.\nrepo\n.\nmangoQuery\n.\ncountTotals\n(\ndomainClass\n,\n \n[\n\n  \ncriteria:\n \n[\nname:\n \nVirgin%\n,\n \ntype:\n \nNew\n]\n\n\n],\n \n[\namount\n,\n \ncredit\n]){\n\n  \ngt\n \nid\n,\n \n5\n\n\n}\n\n\n\nResult will be look like: \n[amount: 1500, credit: 440]\n, it doesn't take into account pagination.\n\n\nScrollableQuery\n\n\nSee \nScrollableQuery\n\n\nExecute a closure for each record\n\n\nAs you can see in the example below, we can specify the SQL query and provide the closure which is called for each record:\n\n\n    \nScrollableQuery\n \nscrollableQuery\n \n=\n \nnew\n \nScrollableQuery\n(\nnew\n \nColumnMapRowMapper\n(),\n \ndataSource\n,\n \n50\n)\n\n\n    \nscrollableQuery\n.\neachRow\n(\nselect * from ScrollableQueryTest\n)\n \n{\n \nObject\n \nrow\n \n-\n\n        \nprintln\n \nrow\n\n    \n}\n\n\n\n\n\nExecute a closure for each batch of records\n\n\nUsing \neachBatch\n we can execute a closure for a batch of records.\nThis closure is called for a specified number of records. For example, code below prints size of each batch\n(which is 5) to console:\n\n\n    \nscrollableQuery\n.\neachBatch\n(\nselect * from ScrollableQueryTest\n,\n \n5\n)\n \n{\n \nList\n \nbatch\n \n-\n\n        \nprintln\n \nbatchSize=${batch.size()}\n\n    \n}\n\n\n\n\n\nFetching a list of all records:\n\n\n\n\nNOTE: This method holds all rows in memory, so this should not be used if there is going to be large number of rows.\n\n\n\n\n    \nList\n \nvalues\n \n=\n \nscrollableQuery\n.\nrows\n(\nselect * from ScrollableQueryTest where value=\ntest\n)\n\n\n\n\n\nGrailsParameterMapRowMapper\n\n\nSee \nGrailsParameterMapRowMapper\n\n\nRow mapper which allows to convert data from a given ResultSet instance\nto a grails parameter map, which can be used for databinding.",
            "title": "Mango Query"
        },
        {
            "location": "/queries-mango/#mango-overview",
            "text": "The primary motive here is to create an easy dynamic way to query via a rest api or using a simple map.\nThe repository comes with a  query(criteriaMap, closure)  method. It allows to get paged list of entities restricted by\nthe properties in the  criteriaMap . The map could be passed as JSON string or Map. All restrictions should be under  criteria  keyword by default, but it can be changed with  config .  Anything in the optional closure will be passed into Gorm/Hibernate criteria closure   A lot of inspiration was drawn from  Restdb.io  the query language is similar to  Mongo's  and CouchDB's new  Mango selector-syntax .  Also inspired by  json-sql     \nWhilst selectors have many similarities with MongoDB query documents, \nthese arise more from a similarity of purpose and do not necessarily extend to commonality of function or result.   Basic example  Org . repo . query ([ \n   criteria :   [ name :   Bill% ,   type :   New ], \n   sort :   [ name : asc ], \n   max :   20  ]){ \n   gt   id ,   5  }   The same result can be reached with criteria:  Criteria   criteria   =   Org . createCriteria ()  criteria . list ( max :   20 )   { \n     ilike   name ,   Bill% \n     eq   type ,   New \n     gt   id ,   5 \n     order ( name ,   asc )  }",
            "title": "Mango Overview"
        },
        {
            "location": "/queries-mango/#restful-api-query",
            "text": "See the docs here for more examples and info  https://yakworks.github.io/gorm-rest-api/",
            "title": "Restful API query"
        },
        {
            "location": "/queries-mango/#mango-ql",
            "text": "The Mango query language is similar to  Mongo's \nand CouchDB's new  Mango selector-syntax \nwith some inspiration from  json-sql  as well",
            "title": "Mango QL"
        },
        {
            "location": "/queries-mango/#logical",
            "text": "Op  Description  Examples      $and  default  $and: [ { name :  Belak }, { status :  D } ]    equivalent to  name :  Belak ,  status :  D    $or  \"ors\" them all  $or: [ { name :  Belak }, { fork : true} ]     $or: { name :  Belak ,  fork : true }    $not  ALL not equal, !=,   $not:{  status :  Destroyed ,  dateStatus :  2371  }    $nor  ANY one is not equal  $nor:{  name :  Romulan ,  fork : 12 }",
            "title": "Logical"
        },
        {
            "location": "/queries-mango/#comparison",
            "text": "Op  Description  Example      $gt    greater than  cargo : { $gt : 10000}    $gte  = greater than or equal  cargo : { $gte : 10000}    $lt    less than  cargo : { $lt : 10000}    $lte  = less than or equal  cargo : { $lte : 10000}    $between  between two distinct values  dateStatus : { $between : [2300, 2400]}    $like  like expression  name : { $like :  Rom% }    $ilike  like auto-append %  name : { $ilike :  rom }    $eq  = equal, concieince for builders  salary : { $eq : 10}  |  salary : 10    $ne  not equal, !=,   age  : { $ne  : 12}}    $in  Match any value in array  field  : { $in  : [value1, value2, ...]    $nin  Not match any value in array  field  : { $nin  : [value1, value2, ...]}    $isNull  Value is null  name :  $isNull  \\| \"name\": null    $isNotNull  Value is not null  name :  $isNotNull  \\| \"name\":{$ne: null}",
            "title": "Comparison"
        },
        {
            "location": "/queries-mango/#fields",
            "text": "Op  Description  Example      $gtf    another field  cargo : { $gtf :  maxCargo }    $gtef  = field  cargo : { $gtef :  maxCargo }    $ltf    field  cargo : { $ltf :  maxCargo }    $ltef  = field  cargo : { $ltef :  maxCargo }    $eqf  = field  cargo : { $eqf :  controlTotal }    $nef  not equal, !=,   cargo  : { $nef  :  controlTotal }}",
            "title": "Fields"
        },
        {
            "location": "/queries-mango/#convert-to-mango-ql",
            "text": "The  MangoTidyMap utility \ntransforms parameters map to Mango QL criteria map. \nHere is several examples of usage:  assert   MangoTidyMap . tidy ([ a : 5 ])   ==   [ a :[ $eq : 5 ]]  assert   MangoTidyMap . tidy ([ b : Bill% ])   ==   [ b :[ $ilike : 5 ]]  assert   MangoTidyMap . tidy ([ c :   [ 1 , 2 , 3 ]])   ==   [ c :[ $in :[ 1 , 2 , 3 ]]]   One of the useful features of the MangoTidyMap is that it converts path to nested map which is required by  mangoQuery  assert   MangoTidyMap . tidy [ a . b . c :   3 ])   ==   [ a :[ b :[ c :[ $eq : 3 ]]]]  \nFor more example take a look on  MangoTidyMapSpec",
            "title": "Convert to Mango QL"
        },
        {
            "location": "/queries-mango/#mango-query",
            "text": "The repository by default does not have all the features of mango service, just  buildCriteria  and  query  methods, but both automatically\nconvert map params to mango map, so just  params  or  request.JSON  can be passed.   See  Mango Api  to know all features that are provided.",
            "title": "Mango query"
        },
        {
            "location": "/queries-mango/#examples",
            "text": "Bellow will be a list of supported syntax for params in json format, which is supported:\nAssume we are running these on star trek characters  http://stapi.co/api/v1/rest/character?uid=CHMA0000128908  { \n   criteria :   { \n     name :   Kira% ,   /* if it ends with % then it will us an ilike */ \n     gender :   F ,   //no % its straight up \n     placeOfBirth :   { $ilike :   bajor% },   /* a case-insensitive  like  expression appends the % */ \n     hologram :   true ,   /* boolean */ \n     createdDate :   1993-05-16T00:00:00.000Z ,   // dates \n     dateOfBirth :   1957-07-26   // dates \n     placeOfBirth :   { $eqf :   $placeOfDeath }   //equals another field in set \n   }, \n   sort : name   // asc by default  }   This would produce in a round about way with criteria builders a where clause like this     ..   name   like   Kira%   AND   gender = F   AND   placeOfBirth   like   bajor%   AND   hologram   =   true \n   AND   createdDate   =   ???   AND   dateOfBirth   =   ???   AND   placeOfBirth   =   placeOfDeath \n   ORDER   BY   name   ASC ,   dateOfBirth   DESC ;",
            "title": "Examples"
        },
        {
            "location": "/queries-mango/#associations",
            "text": "{ \n   criteria :   { \n     customer.id :   101 , \n     customerId :   101 ,   /* check if domain has customerId property, if not then uses customer.id 101 above */ \n     customer :   {   /* nested object way */ \n       id :   101 , \n       name :   Wal% \n     } \n   } \n   sort :   { \n     customer.name :   asc , \n     tranDate :   desc \n   }  }",
            "title": "Associations"
        },
        {
            "location": "/queries-mango/#in-clause",
            "text": "{ \n   criteria :   { \n     customer.id :   [ 101 , 102 , 103 ],   /* an array means it will use in/inList */ \n     customer :   [{ id : 101 },{ id : 102 },{ id : 103 }],   //can be in summarized object form as well \n     customer.id :   [ 101 , 102 , 103 ],   /* an array means it will use in/inList */ \n     //the 3 above are different ways to do this \n     customer.id :   { $in :   [ 101 , 102 , 103 ]}, \n     customer :   { \n       id :   { $in :   [ 101 , 102 , 103 ]} \n     }, \n\n     customer.id :   { $nin :   [ 101 , 102 , 103 ]},   /* an array means it will use `not { in/inList }`*/ \n   }  }",
            "title": "IN Clause"
        },
        {
            "location": "/queries-mango/#fields-comparison-examples",
            "text": "amount :   { $ne :   50 },   /*not equal*/ \n   amount :   { $gt :   100 },   /* greater than value */ \n   amount.$gt :   100   /* another form of the above one, can be useful when json is build, for example from angular model, where  you can t right in object form*/ \n   amount :   { $ge :   100 },   /* greater or equal than value */ \n\n   amount :   { $lt :   $origAmount },   /* less than value of another field*/ \n   amount :   { $le :   $origAmount },   /* less or equal than value */ \n\n   amount : {   //all these will get anded together \n     $gt :   5.0 , \n     $lt :   15.50 , \n     $ne :   9.99 \n   }, \n\n   amount :   { $between :   [ 0 , 100 ]},   /* between value */ \n\n   status :   $isNull   /* translates to isNull*/ \n   status :   { $isNull :   true },   /* translates to isNull*/ \n   status :   { $isNull :   false },   /* translates to not{ isNull}*/ \n   status :   null   /* translates to isNull*/",
            "title": "Fields Comparison Examples"
        },
        {
            "location": "/queries-mango/#logical-operators",
            "text": "$or :   {   // if a single or then it can be done like this \n       customer.name : { $ilike :   wal }, \n       customer.num : { $ilike :   wal } \n     }, \n     $and : [   // multiple ors would need to look like this in an array. only one and can be present too \n       { \n         $or :   { \n           customer.name :   John , \n           customer.name :   Jon \n         } \n       }, \n       { \n         $or :   { \n           customer.name :   Mark , \n           customer.name :   Marc \n         } \n       } \n     ],   /* this would end up generating `.... and ( (customer.name =  John  or customer.name =  Jon )            AND (customer.name =  Mark  or customer.name =  Mark ) ) ....` */ \n\n     $or : [   // again you can only have one of these \n       {   // the and is default and optional and this accomplishes the same thing as example sbelow \n         customer.name :   Mark , \n         $or :   { \n           customer.sales :   { $lt :   10 }, \n           customer.sales :   $isNull \n         } \n       }, \n       { \n         $and :   {   //the and can be explicitly specified too if you wish \n           customer.name :   Jim , \n           customer.sales :   { $lt :   15 } \n         } \n       }, \n     ],   /* this would end up generating          ....          AND          (            (customer.name =  mark  and ( customer.sales   10 or customer.sales IS NULL))            OR            (customer.name =  jim  and customer.sales   15 )          )          .... */ \n   }  }",
            "title": "Logical operators"
        },
        {
            "location": "/queries-mango/#quick-search",
            "text": "Quick search - ability to search by one string in criteria filters against several domain fields, the value for quick\nsearch can be passed in  $quickSearch  or  $q  keywords. \nThere are 2 ways to specify fields that should be searched against:\n1. in static property  quickSearchFields  as list of strings, see example bellow:  class   Org   { \n     String   name \n     Address   address \n\n     static   quickSearchFields   =   [ name ,   address.city ] \n     ...  \n1. default fields in config  gorm : \n     tools : \n         mango : \n             defaultQuickSearch : \n               -   name \n               -   num \n               -   address.city   On application start for all domains that doesn't have a  quickSearchFields  property, the fields from  defaultQuickSearch \nthat each domain contains will be added.   So Mango criteria will add  %  automatically, if quick search string doesn't have it and will apply  ilike  statement\nfor each field in  quickSearchFields . If domain field is not string type, then  eq  statement will be used.  Org . repo . search ([ criteria:   [ $quickSearch :   abc ],   max:   20 ])  \nSo it is the same as:  Criteria   criteria   =   Org . createCriteria ()  criteria . list ( max:   20 )   { \n     or   { \n         ilike   name ,   abc% \n         ilike   address.city ,   abc% \n     }  }",
            "title": "Quick Search"
        },
        {
            "location": "/queries-mango/#configuration",
            "text": "The default  criteria  keyword for the restriction map can be changed in config: gorm:\n    tools:\n        mango:\n            criteriaKeyName: filters  With such configuration restrictions for Mango criteria should be under  filters  keyword.",
            "title": "Configuration"
        },
        {
            "location": "/queries-mango/#mango-api",
            "text": "",
            "title": "Mango API"
        },
        {
            "location": "/queries-mango/#mango-in-the-repository",
            "text": "The Repository  implements  MangoQueryRepo  Trait\nwhich contains implementation for two query methods:  DetachedCriteria   buildCriteria (   Map   params =[:],   Closure   closure = null )   { \n         mangoQuery . buildCriteria ( getDomainClass (),   params ,   closure ) \n     }  \nsee docs for  DetachedCriteria    List   query ( Map   params =[:],   Closure   closure = null ){ \n          mangoQuery . query ( getDomainClass (),   params ,   closure ) \n      }  \nreturns list of entities with pagination. For pagination take a look at  Pager  If one need to override mango bean for a certain repo it can be achieved in two ways:    implement  getMangoQuery()  method that should return instance of the class that implements  MangoQueryApi.trait    register a new bean for custom criteria, and set it for the repo with  @Qualifier  annotation    beans   =   { \n     newMangoQuery ( NewMangoQuery )   }   class   NewMangoQuery   implements   MangoQueryApi   { \n\n     @Override \n     DetachedCriteria   buildCriteria ( Class   domainClass ,   Map   params ,   Closure   closure   =   null )   { \n        return   null \n     } \n\n     @Override \n     List   query ( Class   domainClass ,   Map   params ,   Closure   closure   =   null )   { \n        return   [] \n     }  }   class   CityRepo   extends   DefaultGormRepo City   { \n\n     @Autowired \n     @Qualifier ( newMangoQuery ) \n     NewMangoQuery   mangoQuery  }",
            "title": "Mango in the Repository"
        },
        {
            "location": "/queries-mango/#build-mango-criteria",
            "text": "Under the hood Mango uses  DetachedCriteria  take a look on main  build method \nOne can see that it normalizes params map to make it Mango QL and then adds restrictions to detached criteria based on map,\nif closure is passed then applies it too.",
            "title": "Build Mango criteria"
        },
        {
            "location": "/queries-mango/#count-totals",
            "text": "If one needs to compute totals for some fields,  MangoQuery  \nhas  countTotals  method. Restrictions for it are working in the same way as for query method, so it can be specified \nwith params map and criteria closure.  But the repository beans don't contain this method, so one can call it on mangoQuery bean.\nTo specify what fields sums should be computed for, the list with fields name should be passed.\nSee example: Org . repo . mangoQuery . countTotals ( domainClass ,   [ \n   criteria:   [ name:   Virgin% ,   type:   New ]  ],   [ amount ,   credit ]){ \n   gt   id ,   5  }  \nResult will be look like:  [amount: 1500, credit: 440] , it doesn't take into account pagination.",
            "title": "Count totals"
        },
        {
            "location": "/queries-mango/#scrollablequery",
            "text": "See  ScrollableQuery",
            "title": "ScrollableQuery"
        },
        {
            "location": "/queries-mango/#execute-a-closure-for-each-record",
            "text": "As you can see in the example below, we can specify the SQL query and provide the closure which is called for each record:       ScrollableQuery   scrollableQuery   =   new   ScrollableQuery ( new   ColumnMapRowMapper (),   dataSource ,   50 ) \n\n     scrollableQuery . eachRow ( select * from ScrollableQueryTest )   {   Object   row   - \n         println   row \n     }",
            "title": "Execute a closure for each record"
        },
        {
            "location": "/queries-mango/#execute-a-closure-for-each-batch-of-records",
            "text": "Using  eachBatch  we can execute a closure for a batch of records.\nThis closure is called for a specified number of records. For example, code below prints size of each batch\n(which is 5) to console:       scrollableQuery . eachBatch ( select * from ScrollableQueryTest ,   5 )   {   List   batch   - \n         println   batchSize=${batch.size()} \n     }",
            "title": "Execute a closure for each batch of records"
        },
        {
            "location": "/queries-mango/#fetching-a-list-of-all-records",
            "text": "NOTE: This method holds all rows in memory, so this should not be used if there is going to be large number of rows.        List   values   =   scrollableQuery . rows ( select * from ScrollableQueryTest where value= test )",
            "title": "Fetching a list of all records:"
        },
        {
            "location": "/queries-mango/#grailsparametermaprowmapper",
            "text": "See  GrailsParameterMapRowMapper  Row mapper which allows to convert data from a given ResultSet instance\nto a grails parameter map, which can be used for databinding.",
            "title": "GrailsParameterMapRowMapper"
        },
        {
            "location": "/async/",
            "text": "Asynchronous Processing\n\n\nAsyncBatchSupport\n\n\nThe plugin provides a \nAsyncBatchSupport\n spring bean that can be injected. \nBy default it uses the Gpars implementation provide in \nGparsBatchSupport\n. See those docs for details on the methods\nthat are available. \n\n\nTODO examples",
            "title": "Async"
        },
        {
            "location": "/async/#asynchronous-processing",
            "text": "",
            "title": "Asynchronous Processing"
        },
        {
            "location": "/async/#asyncbatchsupport",
            "text": "The plugin provides a  AsyncBatchSupport  spring bean that can be injected. \nBy default it uses the Gpars implementation provide in  GparsBatchSupport . See those docs for details on the methods\nthat are available.   TODO examples",
            "title": "AsyncBatchSupport"
        },
        {
            "location": "/id-generation/",
            "text": "Database ID Generator\n\n\nThe plugin comes with an implementation of hibernate identity generator for a cross database and NoSQL way to assign Long ids from an in memory incrementor. It uses a central table to track the last used id for each table. This helps a lot when dealing with associations and relationships. It also increases the performance of batch inserts.\n\n\nNewObjectId table\n\n\nThe table name is configurable and will get created if it does not exist. You can also create the table as shown below and add indexes if desired.\n\n\ncreate\n \ntable\n \nNewObjectId\n\n\n(\n\n    \nKeyName\n \nvarchar\n(\n255\n)\n \nnot\n \nnull\n \nprimary\n \nkey\n,\n\n    \nNextId\n \nbigint\n \nnot\n \nnull\n\n\n)\n\n\n;\n\n\n\n\n\nHere key name will be the name of the tables and NextId is the next id to return for the given table.\n\n\nConfigure Identity generator globally.\n\n\nThe identity generator can be configured globally in application.groovy as shown below.\n\n\ngrails\n \n{\n\n\n    \ngorm\n.\ndefault\n.\nmapping\n \n=\n \n{\n\n        \nid\n \ncolumn:\n \nid\n,\n \ngenerator:\ngorm.tools.hibernate.PooledTableIdGenerator\n\n    \n}\n\n\n}\n\n\n\n\n\nThis will use the PooledTableIdGenerator for all domains in the application. However it can be done per domain too if required.\n\n\nUsing IdGenerator programmatically\n\n\nPlugin defines a bean with name idGenerator that can be used to programmatically generate new Ids.\nHere is an example domain class.\n\n\nclass\n \nBook\n \n{\n\n    \ntransient\n \nidGenerator\n\n\n    \ndef\n \nbeforeInsert\n()\n \n{\n\n        \nif\n(!\nid\n)\n \nid\n \n=\n \nidGenerator\n.\ngetNextId\n(\nBook.id\n)\n \n// or idGenerator.getNextId(this)\n\n    \n}\n\n\n}\n\n\n\n\n\nIdentity generator will check in NewObjectId table for keyName \nBook\n If it exists, it will return the value of NextId or else it will insert a new row in NewObjectId table.\n\n\nHow it works\n\n\nBy default the following beans are enabled.\n\n\njdbcIdGenerator\n\nA Jdbc implementation of the IdGenerator, it uses NewObjectId central table to query the new ids.\n\n\nidGenerator(BatchIdGenerator)\n\nIdgenerator implementation that caches a range of values in memory by the key name. It caches a batch of id for each key and increments in memory thus provides better performance.\nInternally it uses jdbcIdGenerator to query for next batch of ids.\n\n\nBatchIdGenerator by default uses allocationSize size of 100. Which can be changed by overriding the spring bean as shown below.\n\n\n \nidGenerator\n(\nBatchIdGenerator\n){\n\n    \ngenerator\n \n=\n \nref\n(\njdbcIdGenerator\n)\n\n    \nallocationSize\n \n=\n \n50\n\n  \n}\n\n\n\n\n\nThe plugin by default configures the BatchIdGenerator as default idgenerator. If you need to use another idgenerator or provide a custom implementation, you can override the \nidGenerator\n spring bean.\n\n\njdbcTemplate\n\nThis plugin also configures JdbcTemplate which can be used for low level jdbc access. It uses TransactionAwareDataSourceProxy so the queries run through the jdbcTemplate will be part of the current transaction.",
            "title": "Id Generation"
        },
        {
            "location": "/id-generation/#database-id-generator",
            "text": "The plugin comes with an implementation of hibernate identity generator for a cross database and NoSQL way to assign Long ids from an in memory incrementor. It uses a central table to track the last used id for each table. This helps a lot when dealing with associations and relationships. It also increases the performance of batch inserts.",
            "title": "Database ID Generator"
        },
        {
            "location": "/id-generation/#newobjectid-table",
            "text": "The table name is configurable and will get created if it does not exist. You can also create the table as shown below and add indexes if desired.  create   table   NewObjectId  ( \n     KeyName   varchar ( 255 )   not   null   primary   key , \n     NextId   bigint   not   null  )  ;   Here key name will be the name of the tables and NextId is the next id to return for the given table.",
            "title": "NewObjectId table"
        },
        {
            "location": "/id-generation/#configure-identity-generator-globally",
            "text": "The identity generator can be configured globally in application.groovy as shown below.  grails   { \n\n     gorm . default . mapping   =   { \n         id   column:   id ,   generator: gorm.tools.hibernate.PooledTableIdGenerator \n     }  }   This will use the PooledTableIdGenerator for all domains in the application. However it can be done per domain too if required.",
            "title": "Configure Identity generator globally."
        },
        {
            "location": "/id-generation/#using-idgenerator-programmatically",
            "text": "Plugin defines a bean with name idGenerator that can be used to programmatically generate new Ids.\nHere is an example domain class.  class   Book   { \n     transient   idGenerator \n\n     def   beforeInsert ()   { \n         if (! id )   id   =   idGenerator . getNextId ( Book.id )   // or idGenerator.getNextId(this) \n     }  }   Identity generator will check in NewObjectId table for keyName  Book  If it exists, it will return the value of NextId or else it will insert a new row in NewObjectId table.",
            "title": "Using IdGenerator programmatically"
        },
        {
            "location": "/id-generation/#how-it-works",
            "text": "By default the following beans are enabled.  jdbcIdGenerator \nA Jdbc implementation of the IdGenerator, it uses NewObjectId central table to query the new ids.  idGenerator(BatchIdGenerator) \nIdgenerator implementation that caches a range of values in memory by the key name. It caches a batch of id for each key and increments in memory thus provides better performance.\nInternally it uses jdbcIdGenerator to query for next batch of ids.  BatchIdGenerator by default uses allocationSize size of 100. Which can be changed by overriding the spring bean as shown below.    idGenerator ( BatchIdGenerator ){ \n     generator   =   ref ( jdbcIdGenerator ) \n     allocationSize   =   50 \n   }   The plugin by default configures the BatchIdGenerator as default idgenerator. If you need to use another idgenerator or provide a custom implementation, you can override the  idGenerator  spring bean.  jdbcTemplate \nThis plugin also configures JdbcTemplate which can be used for low level jdbc access. It uses TransactionAwareDataSourceProxy so the queries run through the jdbcTemplate will be part of the current transaction.",
            "title": "How it works"
        },
        {
            "location": "/gorm-utils/",
            "text": "Gorm-tools provides two utils to work with domains.\nSee \nGormUtils\n\nand \nGormMetaUtils\n\n\nGormUtils\n\n\nCoping properties from source to target domain instance\n\n\nUsing \ncopyProperties\n we can copy some of properties from one domain to another:\n\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n)\n\n    \nUser\n \nuser2\n \n=\n \nnew\n \nUser\n()\n\n    \nUser\n \nuser3\n \n=\n \nnew\n \nUser\n()\n\n\n    \nGormUtils\n.\ncopyProperties\n(\nuser\n,\n \nuser2\n,\n \nfalse\n,\n \nfirstName\n)\n\n    \nGormUtils\n.\ncopyProperties\n(\nuser\n,\n \nuser3\n,\n \nfalse\n,\n \nfirstName\n,\n \nage\n)\n\n\n    \nassert\n \nuser2\n.\nfirstName\n \n==\n \nuser\n.\nfirstName\n\n    \nassert\n \nuser2\n.\nage\n \n!=\n \nuser\n.\nage\n\n\n    \nassert\n \nuser3\n.\nfirstName\n \n==\n \nuser\n.\nfirstName\n\n    \nassert\n \nuser3\n.\nage\n \n==\n \nuser\n.\nage\n\n\n\nIn this example \nuser\n is the source object, \nuser2\n and \nuser3\n are targets.\nIf the 3\nrd\n argument is false the method will override a target value even if it's not null.\nThen we can specify properties to copy from the source object.\n\n\nFetching a nested property using a string name\n\n\nGormUtils allows us to get a nested property from an object using a string as a path:\n\n\n    \nAddress\n \naddress\n \n=\n \nnew\n \nAddress\n(\nstreet:\n \nstreet\n,\n \ncity:\n \ncity\n)\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n,\n \naddress:\n \naddress\n)\n\n\n    \nString\n \nstreet\n \n=\n \nGormUtils\n.\ngetPropertyValue\n(\nperson\n,\n \naddress.street\n)\n\n\n    \nassert\n \nstreet\n \n==\n \naddress\n.\nstreet\n\n\n\nAs you can see we can specify nested properties simply by adding a ( \n.\n ) symbol to a parent's property name.\n\n\nCopying a domain instance\n\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n)\n\n\n    \nUser\n \ncopy\n \n=\n \nGormUtils\n.\ncopyDomain\n(\nUser\n,\n \nuser\n)\n\n    \nassert\n \ncopy\n.\nfirstName\n \n==\n \nJohn\n\n    \nassert\n \ncopy\n.\nlastName\n \n==\n \nDoe\n\n    \nassert\n \ncopy\n.\nage\n \n==\n \n30\n\n\n\nor with existing object\n\n\n    \nUser\n \ncopy\n \n=\n \nGormUtils\n.\ncopyDomain\n(\nnew\n \nUser\n(),\n \nuser\n)\n\n    \nassert\n \ncopy\n.\nfirstName\n \n==\n \nJohn\n\n    \nassert\n \ncopy\n.\nlastName\n \n==\n \nDoe\n\n    \nassert\n \ncopy\n.\nage\n \n==\n \n30\n\n\n\n\n\nGormMetaUtils\n\n\nGetting a domain class\n\n\n    \n// using a fully qualified name with package\n\n    \nGormMetaUtils\n.\ngetDomainClass\n(\ngorm.tools.Org\n)\n\n\n    \n// using a domain instance\n\n    \nGormMetaUtils\n.\ngetDomainClass\n(\nnew\n \nOrg\n())\n\n\n    \n// using a class\n\n    \nGormMetaUtils\n.\ngetDomainClass\n(\nOrg\n)\n\n\n\n\n\nGetting a persistent entity\n\n\n    \n// using a fully qualified name with package\n\n    \nGormMetaUtils\n.\ngetPersistentEntity\n(\ngorm.tools.Org\n)\n\n\n    \n// using a domain instance\n\n    \nGormMetaUtils\n.\ngetPersistentEntity\n(\nnew\n \nOrg\n())\n\n\n    \n// using a class\n\n    \nGormMetaUtils\n.\ngetPersistentEntity\n(\nOrg\n)",
            "title": "GormUtils Class"
        },
        {
            "location": "/gorm-utils/#gormutils",
            "text": "",
            "title": "GormUtils"
        },
        {
            "location": "/gorm-utils/#coping-properties-from-source-to-target-domain-instance",
            "text": "Using  copyProperties  we can copy some of properties from one domain to another:       User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ) \n     User   user2   =   new   User () \n     User   user3   =   new   User () \n\n     GormUtils . copyProperties ( user ,   user2 ,   false ,   firstName ) \n     GormUtils . copyProperties ( user ,   user3 ,   false ,   firstName ,   age ) \n\n     assert   user2 . firstName   ==   user . firstName \n     assert   user2 . age   !=   user . age \n\n     assert   user3 . firstName   ==   user . firstName \n     assert   user3 . age   ==   user . age  \nIn this example  user  is the source object,  user2  and  user3  are targets.\nIf the 3 rd  argument is false the method will override a target value even if it's not null.\nThen we can specify properties to copy from the source object.",
            "title": "Coping properties from source to target domain instance"
        },
        {
            "location": "/gorm-utils/#fetching-a-nested-property-using-a-string-name",
            "text": "GormUtils allows us to get a nested property from an object using a string as a path:       Address   address   =   new   Address ( street:   street ,   city:   city ) \n     User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ,   address:   address ) \n\n     String   street   =   GormUtils . getPropertyValue ( person ,   address.street ) \n\n     assert   street   ==   address . street  \nAs you can see we can specify nested properties simply by adding a (  .  ) symbol to a parent's property name.",
            "title": "Fetching a nested property using a string name"
        },
        {
            "location": "/gorm-utils/#copying-a-domain-instance",
            "text": "User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ) \n\n     User   copy   =   GormUtils . copyDomain ( User ,   user ) \n     assert   copy . firstName   ==   John \n     assert   copy . lastName   ==   Doe \n     assert   copy . age   ==   30  \nor with existing object       User   copy   =   GormUtils . copyDomain ( new   User (),   user ) \n     assert   copy . firstName   ==   John \n     assert   copy . lastName   ==   Doe \n     assert   copy . age   ==   30",
            "title": "Copying a domain instance"
        },
        {
            "location": "/gorm-utils/#gormmetautils",
            "text": "",
            "title": "GormMetaUtils"
        },
        {
            "location": "/gorm-utils/#getting-a-domain-class",
            "text": "// using a fully qualified name with package \n     GormMetaUtils . getDomainClass ( gorm.tools.Org ) \n\n     // using a domain instance \n     GormMetaUtils . getDomainClass ( new   Org ()) \n\n     // using a class \n     GormMetaUtils . getDomainClass ( Org )",
            "title": "Getting a domain class"
        },
        {
            "location": "/gorm-utils/#getting-a-persistent-entity",
            "text": "// using a fully qualified name with package \n     GormMetaUtils . getPersistentEntity ( gorm.tools.Org ) \n\n     // using a domain instance \n     GormMetaUtils . getPersistentEntity ( new   Org ()) \n\n     // using a class \n     GormMetaUtils . getPersistentEntity ( Org )",
            "title": "Getting a persistent entity"
        },
        {
            "location": "/beanPathTools/",
            "text": "Gorm-tools comes with BeanPathTools util which provides a convenient way for manipulating with object's properties.\nSee \nBeanPathTools\n\n\nGetting specified object's properties to a map\n\n\nIn order to retrieve properties from an object and place them to a map we can use \nbuildMapFromPaths\n\nWe can possible to specify fields which should be added to the resulting map\nby providing a list with property names as the second argument.\n\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n)\n\n\n    \nMap\n \nuserName\n \n=\n \nBeanPathTools\n.\nbuildMapFromPaths\n(\nuser\n,\n \n[\nfirstName\n,\n \nlastName\n])\n\n    \nassert\n \nuserName\n \n==\n \n[\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n]\n\n\n\n\n\nGetting nested properties:\n\n\nIt is also works well with nested properties. To get a nested property we need to specify\na full path including parent field names divided with the ( \n.\n ) sign. See example below:\n\n\n    \nAddress\n \naddress\n \n=\n \nnew\n \nAddress\n(\nstreet1:\n \nstreet1\n,\n \nstreet2:\n \nstreet2\n \nzip:\n \n123456\n,\n \ncity:\n \ncity\n)\n\n    \nUser\n \nuser\n \n=\n \nnew\n \nUser\n(\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n,\n \naddress:\n \naddress\n)\n\n\n    \nMap\n \nstreet\n \n=\n \nBeanPathTools\n.\nbuildMapFromPaths\n(\nuser\n,\n \n[\naddress.street1\n,\n \naddress.street2\n])\n\n    \nassert\n \nstreet\n \n==\n \n[\naddress:\n \n[\nstreet1:\n \nstreet1\n,\n \nstreet2:\n \nstreet2\n]]\n\n\n    \nMap\n \nfullAddress\n \n=\n \nBeanPathTools\n.\nbuildMapFromPaths\n(\nuser\n,\n \n[\naddress.*\n])\n\n    \nassert\n \nfullAddress\n \n==\n \n[\naddress:\n \n[\nstreet1:\n \nstreet1\n,\n \nstreet2:\n \nstreet2\n \nzip:\n \n123456\n,\n \ncity:\n \ncity\n]]\n\n\n\n\n\nGetting all object's properties to a map\n\n\n\n\nNOTE: in case of a domain instance the method looks only for persistent properties\n\n\n\n\nThe ( \n*\n )  sign represents all properties. Thus in order to get all fields we can use it as shown below:\n\n\n    \nMap\n \nuserMap\n \n=\n \nBeanPathTools\n.\nbuildMapFromPaths\n(\nuser\n,\n \n[\n*\n])\n\n    \nassert\n \nuserMap\n \n==\n \n[\nfirstName:\n \nJohn\n,\n \nlastName:\n \nDoe\n \nage:\n \n30\n]",
            "title": "Bean Path Tools"
        },
        {
            "location": "/beanPathTools/#getting-specified-objects-properties-to-a-map",
            "text": "In order to retrieve properties from an object and place them to a map we can use  buildMapFromPaths \nWe can possible to specify fields which should be added to the resulting map\nby providing a list with property names as the second argument.       User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ) \n\n     Map   userName   =   BeanPathTools . buildMapFromPaths ( user ,   [ firstName ,   lastName ]) \n     assert   userName   ==   [ firstName:   John ,   lastName:   Doe ]",
            "title": "Getting specified object's properties to a map"
        },
        {
            "location": "/beanPathTools/#getting-nested-properties",
            "text": "It is also works well with nested properties. To get a nested property we need to specify\na full path including parent field names divided with the (  .  ) sign. See example below:       Address   address   =   new   Address ( street1:   street1 ,   street2:   street2   zip:   123456 ,   city:   city ) \n     User   user   =   new   User ( firstName:   John ,   lastName:   Doe   age:   30 ,   address:   address ) \n\n     Map   street   =   BeanPathTools . buildMapFromPaths ( user ,   [ address.street1 ,   address.street2 ]) \n     assert   street   ==   [ address:   [ street1:   street1 ,   street2:   street2 ]] \n\n     Map   fullAddress   =   BeanPathTools . buildMapFromPaths ( user ,   [ address.* ]) \n     assert   fullAddress   ==   [ address:   [ street1:   street1 ,   street2:   street2   zip:   123456 ,   city:   city ]]",
            "title": "Getting nested properties:"
        },
        {
            "location": "/beanPathTools/#getting-all-objects-properties-to-a-map",
            "text": "NOTE: in case of a domain instance the method looks only for persistent properties   The (  *  )  sign represents all properties. Thus in order to get all fields we can use it as shown below:       Map   userMap   =   BeanPathTools . buildMapFromPaths ( user ,   [ * ]) \n     assert   userMap   ==   [ firstName:   John ,   lastName:   Doe   age:   30 ]",
            "title": "Getting all object's properties to a map"
        },
        {
            "location": "/working-with-dates/",
            "text": "Gorm-tools provides a set of static utils which allow us to manipulate with dates much easier.\n\n\nDateUtil\n\n\nSee \nDateUtil\n\n\nParsing a date in a string\n\n\nstringToDate\n expects a string with date in the simple format \nyyyy-MM-dd\n and returns Date instance:\n\n\n     \nDate\n \ndate\n \n=\n \nDateUtil\n.\nstringToDate\n(\n2017-10-19\n)\n\n\n     \nassert\n \ndate\n\n     \nassert\n \ndate\n \n==\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd\n).\nparse\n(\n2017-10-19\n)\n\n\n\n\n\nit's a shortcut for \nconvertStringToDateTime\n\n\n     \nDate\n \ndate\n \n=\n \nDateUtil\n.\nconvertStringToDateTime\n(\n2017-10-19\n,\n \nyyyy-MM-dd\n)\n\n\n     \nassert\n \ndate\n\n     \nassert\n \ndate\n \n==\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd\n).\nparse\n(\n2017-10-19\n)\n\n\n\n\n\nConverting Date instance to a string\n\n\ndateToJsonString\n converts a date to the format \nyyyy-MM-dd'T'HH:mm:ss.SSSZ\n\n\n    \nDate\n \ndate\n \n=\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd HH:mm:ss\n).\nparse\n(\n2017-10-20 22:00:00\n)\n\n\n    \nString\n \nresult\n \n=\n \nDateUtil\n.\ndateToJsonString\n(\ndate\n)\n\n    \nassert\n \nresult\n \n==\n \ndate\n.\nformat\n(\nyyyy-MM-dd\nT\nHH:mm:ss.SSSZ\n)\n\n\n\n\n\nit's a shortcut for \ndateToString\n method which accepts a format\n\n\n    \nDate\n \ndate\n \n=\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd HH:mm:ss\n).\nparse\n(\n2017-10-20 22:00:00\n)\n\n\n    \nString\n \nresult\n \n=\n \nDateUtil\n.\ndateToString\n(\ndate\n,\n \nyyyy-MM-dd\nT\nHH:mm:ss.SSSZ\n)\n\n    \nassert\n \nresult\n \n==\n \ndate\n.\nformat\n(\nyyyy-MM-dd\nT\nHH:mm:ss.SSSZ\n)\n\n\n\n    \nresult\n \n=\n \nDateUtil\n.\ndateToString\n(\ndate\n)\n\n    \nassert\n \nresult\n \n==\n \ndate\n.\nformat\n(\nMM/dd/yyyy hh:mm:ss\n)\n\n\n\n\n\nGet the difference now and a specified date in hours\n\n\n    \nCalendar\n \ncalendar\n \n=\n \nCalendar\n.\ngetInstance\n()\n\n    \ncalendar\n.\nadd\n(\nCalendar\n.\nHOUR\n,\n \n1\n)\n\n    \ncalendar\n.\nadd\n(\nCalendar\n.\nMINUTE\n,\n \n30\n)\n\n\n    \nassert\n \n1L\n \n=\n \nDateUtil\n.\ngetDateDifference_inHours\n(\ncalendar\n.\ngetTime\n())\n\n\n\n\n\nGet the difference between dates\n\n\nWe can calculate get number of months between two dates, for example:\n\n\n    \nSimpleDateFormat\n \nformat\n \n=\n \nnew\n \nSimpleDateFormat\n(\nyyyy-MM-dd\n)\n\n    \nDate\n \ndate1\n \n=\n \nformat\n.\nparse\n(\n2017-10-19\n)\n\n    \nDate\n \ndate2\n \n=\n \nformat\n.\nparse\n(\n2017-12-19\n)\n\n\n    \n2\n \n==\n \nDateUtil\n.\ngetMonthDiff\n(\ndate1\n,\n \ndate2\n)\n\n\n\n\n\nor number of days\n\n\n    \nDate\n \nnow\n \n=\n \nnew\n \nDate\n()\n\n\n    \nassert\n \n0\n \n==\n \nDateUtil\n.\ngetDaysBetween\n(\nnow\n,\n \nnow\n)\n\n    \nassert\n \n-\n10\n \n==\n \nDateUtil\n.\ngetDaysBetween\n(\nnow\n \n-\n \n10\n,\n \nnow\n)\n\n    \nassert\n  \n10\n \n==\n \nDateUtil\n.\ngetDaysBetween\n(\nnow\n \n+\n \n10\n,\n \nnow\n)\n\n\n\n\n\nMultiFormatDateConverter\n\n\nMultiFormatDateConverter extends general type conversion system for dates. It is used to date formatted string to date.\n\n\nUnder the hood it uses DateUtil and supports next formats \"yyyy-MM-dd\", \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", \"yyyy-MM-dd'T'HH:mm:ssZ\",\n\"yyyy-MM-dd'T'HH:mm:ss\", \"MM/dd/yy\"\n\n\nTo apply it to application add a spring bean for it. The bean name could be any",
            "title": "Date Utils"
        },
        {
            "location": "/working-with-dates/#dateutil",
            "text": "See  DateUtil",
            "title": "DateUtil"
        },
        {
            "location": "/working-with-dates/#parsing-a-date-in-a-string",
            "text": "stringToDate  expects a string with date in the simple format  yyyy-MM-dd  and returns Date instance:        Date   date   =   DateUtil . stringToDate ( 2017-10-19 ) \n\n      assert   date \n      assert   date   ==   new   SimpleDateFormat ( yyyy-MM-dd ). parse ( 2017-10-19 )   it's a shortcut for  convertStringToDateTime        Date   date   =   DateUtil . convertStringToDateTime ( 2017-10-19 ,   yyyy-MM-dd ) \n\n      assert   date \n      assert   date   ==   new   SimpleDateFormat ( yyyy-MM-dd ). parse ( 2017-10-19 )",
            "title": "Parsing a date in a string"
        },
        {
            "location": "/working-with-dates/#converting-date-instance-to-a-string",
            "text": "dateToJsonString  converts a date to the format  yyyy-MM-dd'T'HH:mm:ss.SSSZ       Date   date   =   new   SimpleDateFormat ( yyyy-MM-dd HH:mm:ss ). parse ( 2017-10-20 22:00:00 ) \n\n     String   result   =   DateUtil . dateToJsonString ( date ) \n     assert   result   ==   date . format ( yyyy-MM-dd T HH:mm:ss.SSSZ )   it's a shortcut for  dateToString  method which accepts a format       Date   date   =   new   SimpleDateFormat ( yyyy-MM-dd HH:mm:ss ). parse ( 2017-10-20 22:00:00 ) \n\n     String   result   =   DateUtil . dateToString ( date ,   yyyy-MM-dd T HH:mm:ss.SSSZ ) \n     assert   result   ==   date . format ( yyyy-MM-dd T HH:mm:ss.SSSZ ) \n\n\n     result   =   DateUtil . dateToString ( date ) \n     assert   result   ==   date . format ( MM/dd/yyyy hh:mm:ss )",
            "title": "Converting Date instance to a string"
        },
        {
            "location": "/working-with-dates/#get-the-difference-now-and-a-specified-date-in-hours",
            "text": "Calendar   calendar   =   Calendar . getInstance () \n     calendar . add ( Calendar . HOUR ,   1 ) \n     calendar . add ( Calendar . MINUTE ,   30 ) \n\n     assert   1L   =   DateUtil . getDateDifference_inHours ( calendar . getTime ())",
            "title": "Get the difference now and a specified date in hours"
        },
        {
            "location": "/working-with-dates/#get-the-difference-between-dates",
            "text": "We can calculate get number of months between two dates, for example:       SimpleDateFormat   format   =   new   SimpleDateFormat ( yyyy-MM-dd ) \n     Date   date1   =   format . parse ( 2017-10-19 ) \n     Date   date2   =   format . parse ( 2017-12-19 ) \n\n     2   ==   DateUtil . getMonthDiff ( date1 ,   date2 )   or number of days       Date   now   =   new   Date () \n\n     assert   0   ==   DateUtil . getDaysBetween ( now ,   now ) \n     assert   - 10   ==   DateUtil . getDaysBetween ( now   -   10 ,   now ) \n     assert    10   ==   DateUtil . getDaysBetween ( now   +   10 ,   now )",
            "title": "Get the difference between dates"
        },
        {
            "location": "/working-with-dates/#multiformatdateconverter",
            "text": "MultiFormatDateConverter extends general type conversion system for dates. It is used to date formatted string to date.  Under the hood it uses DateUtil and supports next formats \"yyyy-MM-dd\", \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", \"yyyy-MM-dd'T'HH:mm:ssZ\",\n\"yyyy-MM-dd'T'HH:mm:ss\", \"MM/dd/yy\"  To apply it to application add a spring bean for it. The bean name could be any",
            "title": "MultiFormatDateConverter"
        },
        {
            "location": "/api/",
            "text": "The Groovy/Java Docs API can be found here\n\n\nhttps://yakworks.github.io/gorm-tools/api/",
            "title": "API Docs"
        }
    ]
}
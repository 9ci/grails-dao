{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nSince we were setting up a bunch of services that looked a lot like the old school Dao's. We figured we would just call them that instead of data services, repository, etc...\n\n\nPurpose\n\n\n\n\nTo provide standardization across our apps for transactional saves using failOnError:true to throw a Runtime Exception without changing config. see persist() method.\n\n\nensure that each call to persist() will create a Transaction if its not already inside of one. See more about the problems that can occur in example below.\n\n\nA clean standard way to abstract boiler plate business logic from the controller into a this dao service for databinding maps and JSON. Works somewhat like gorm's new data services. \n\n\neasily allows validation outside of constraints to persistence without needing to modify the domain source. For example, if I have a \nThing\n domain in my things plugin and I need to customize the validation logic for an insert in my Fancy-Thing app or perhaps implement events, I can simply create a ThingDao in the Fancy-Thing that overrides the one in the Thing plugin. \n\n\n\n\nProblems with doing more advanced persistence that you can in beforeInsert, beforeUpdate, etc with the build in GORM. As mentioned in the gorm docs\n\n\n\n\nDo not attempt to flush the session within an event (such as with obj.save(flush:true)). Since events are fired during flushing this will cause a StackOverflowError.\"\n\n\n\n\n\n\nwe ran into a number of problems, as many do, with session managment here. A dao service creates simple centraolized contract for how to do this without suffering from the session limitations in hibernate/gorm\n\n\n\n\n\n\n\n\nIf you are using envers or cascade saves then we want the saves and updates to be in a transaction by default and a proper thrown error to cause a roll back of all the changes. Not something you get with failOnError:false.\n\n\nExample of the transaction propogation issue:\n \n\n\nWith the cascade save of an association where we were saving a Parent with new Child. The issue will kick in  when new Child saved and blew up and the Parent changes stay. We have a good example of this issue in the demo-app under test\n\n\nWith this plugin and a controller you can just do:\n\n\ndef\n \nupdate\n(){\n\n  \ntry\n{\n\n    \ndef\n \nresult\n \n=\n \nYourDomainClass\n.\nupdate\n(\np\n)\n\n      \nflash\n.\nmessage\n \n=\n \nresult\n.\nmessage\n\n      \nredirect\n(\naction:\n \nshow\n,\n \nid:\n \nresult\n.\nentity\n.\nid\n)\n\n  \n}\ncatch\n(\nDomainException\n \ne\n){\n\n    \nflash\n.\nmessage\n \n=\n \ne\n.\nmessageMap\n\n    \nrender\n(\nview:\n \nedit\n,\n \nmodel:\n \n[(\ndomainInstanceName\n):\n \ne\n.\nentity\n])\n\n  \n}\n\n\n}\n\n\n\n\n\nEach domain gets injected with its own static dao object based on the GormDaoSupport service. If it finds a service that in the form of \nDao that is in any services or dao dir under grai-app then it will use that.\n\n\nExample\n You can setup your own dao for the domain like so and keep the logic in your Dao service and leave the controller alone as all the logic will flow over\n\n\nSee \nGormDaoSupport\n\n\nclass OrgDao extends GormDaoSupport{ \n    def domainClass = Org\n\n    def update(params){\n        ... do some stuff to the params\n        def result = super.update(params)\n        ... do something like log history or send emai with result.entity which is the saved org\n        return result\n    }\n}\n\n\n\n\nInstallation\n\n\nGetting Started\n\n\nDomain Traits\n\n\nDynamic methods added to the domains\n\n\nEvery domain gets a dao which is either setup for you or setup by extending e \nGormDaoSupport\n. Each method is transactional to prevent incomplete cascading saves as exaplained above.\n\n\npersist()\n: calls the dao.save which in turn calls the dao.save(args) and then domain.save(failOnError:true) with any other args passed in. ex: someDomain.persist(). Throws a \nDomainException\n if anything goes wrong \n\n\nremove()\n:  calls the dao.delete which calls the dao.remove(args) which in turn calls the domain.delete(flush:true) by defualt. Throws a \nDomainException\n if anything goes wrong \n\n\nStatics added to the domain\n\n\ninsertAndSave(params)\n:  calls the dao.insert which does the bolier plate code you might find in a scaffolded controller. creates a new instance, sets the params and calls the dao.save (esentially the persist()). \nex:\n Book.insertAndSave([name:'xyz',isbn:'123']) Throws a \nDomainException\n if anything goes wrong\n\n\nupdate(params)\n:  calls the dao.update which does the bolier plate code you might find in a scaffolded controller. gets the instance base in the params.id, sets the params and calls the dao.save for it. \nex:\n Book.update([id:11,name:'aaa']) Throws a (DomainException)[\nhttps://github.com/9ci/grails-dao/blob/master/dao-plugin/src/groovy/grails/plugin/dao/DomainException.groovy\n) if anything goes wrong \n\n\nremove(params)\n:  calls the dao.delete gets the instance base in the params.id, calls the delete for it. \nex:\n Book.remove([id:11]) Throws a \nDomainException\n if anything goes wrong \n\n\ndao\n: a quick way to get to the dao for the Domain. It will return the stock dao that was created from GormDaoSupport or the Dao you created for the domain.\n\n\nDaoUtil and DaoMessage\n\n\nSee \nDaoUtil\n\n\nDaoUtil:\n\n\ncheckFound(entity, Map params,String domainClassName)\n checks does the entity exists, if not throws DomainNotFoundException with human readable error text\n\n\ncheckVersion(entity,ver)\n checks the passed in version with the version on the entity (entity.version) make sure entity.version is not greater, throws DomainException\n\n\nflush()\n flushes the session\n\n\nclear()\n clears session cache\n\n\nflushAndClear()\n flushes the session and clears the session cache\n\n\nDaoMessage contains bunch of help methods for creating text messages\n\n\nSee \nDaoMessage\n\n\nGrails 3:\n\n\nDynamic methods were implemented with trait instead of meta programing, so now \n@CompileStatic\n can be used.\nDue to this changes static method \ninsert\n for domain objects was renamed to \ninsertAndSave\n, because domain class instances\nalready have \ninsert\n method and we can't have both static and instance methods with same list of args.\n\n\nExample\n To be able to use advantages of the dao plugin for REST apps, extend controller from RestDaoController:\n\n\nSee \nRestDaoController\n\n\nclass OrgController extends RestDaoController\nOrg\n {\n    static responseFormats = [\njson\n]\n    static namespace = \napi\n\n\n    OrgController() {\n        super(Org)\n    }\n}\n\n\n\n\nIf controller is extended for RestDaoController then methods will use dao services for current domain. For example\nPOST action will call dao insert method for Org domain.",
            "title": "Overview"
        },
        {
            "location": "/#introduction",
            "text": "Since we were setting up a bunch of services that looked a lot like the old school Dao's. We figured we would just call them that instead of data services, repository, etc...  Purpose   To provide standardization across our apps for transactional saves using failOnError:true to throw a Runtime Exception without changing config. see persist() method.  ensure that each call to persist() will create a Transaction if its not already inside of one. See more about the problems that can occur in example below.  A clean standard way to abstract boiler plate business logic from the controller into a this dao service for databinding maps and JSON. Works somewhat like gorm's new data services.   easily allows validation outside of constraints to persistence without needing to modify the domain source. For example, if I have a  Thing  domain in my things plugin and I need to customize the validation logic for an insert in my Fancy-Thing app or perhaps implement events, I can simply create a ThingDao in the Fancy-Thing that overrides the one in the Thing plugin.    Problems with doing more advanced persistence that you can in beforeInsert, beforeUpdate, etc with the build in GORM. As mentioned in the gorm docs   Do not attempt to flush the session within an event (such as with obj.save(flush:true)). Since events are fired during flushing this will cause a StackOverflowError.\"    we ran into a number of problems, as many do, with session managment here. A dao service creates simple centraolized contract for how to do this without suffering from the session limitations in hibernate/gorm     If you are using envers or cascade saves then we want the saves and updates to be in a transaction by default and a proper thrown error to cause a roll back of all the changes. Not something you get with failOnError:false.  Example of the transaction propogation issue:    With the cascade save of an association where we were saving a Parent with new Child. The issue will kick in  when new Child saved and blew up and the Parent changes stay. We have a good example of this issue in the demo-app under test  With this plugin and a controller you can just do:  def   update (){ \n   try { \n     def   result   =   YourDomainClass . update ( p ) \n       flash . message   =   result . message \n       redirect ( action:   show ,   id:   result . entity . id ) \n   } catch ( DomainException   e ){ \n     flash . message   =   e . messageMap \n     render ( view:   edit ,   model:   [( domainInstanceName ):   e . entity ]) \n   }  }   Each domain gets injected with its own static dao object based on the GormDaoSupport service. If it finds a service that in the form of  Dao that is in any services or dao dir under grai-app then it will use that.  Example  You can setup your own dao for the domain like so and keep the logic in your Dao service and leave the controller alone as all the logic will flow over  See  GormDaoSupport  class OrgDao extends GormDaoSupport{ \n    def domainClass = Org\n\n    def update(params){\n        ... do some stuff to the params\n        def result = super.update(params)\n        ... do something like log history or send emai with result.entity which is the saved org\n        return result\n    }\n}",
            "title": "Introduction"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/#domain-traits",
            "text": "",
            "title": "Domain Traits"
        },
        {
            "location": "/#dynamic-methods-added-to-the-domains",
            "text": "Every domain gets a dao which is either setup for you or setup by extending e  GormDaoSupport . Each method is transactional to prevent incomplete cascading saves as exaplained above.  persist() : calls the dao.save which in turn calls the dao.save(args) and then domain.save(failOnError:true) with any other args passed in. ex: someDomain.persist(). Throws a  DomainException  if anything goes wrong   remove() :  calls the dao.delete which calls the dao.remove(args) which in turn calls the domain.delete(flush:true) by defualt. Throws a  DomainException  if anything goes wrong",
            "title": "Dynamic methods added to the domains"
        },
        {
            "location": "/#statics-added-to-the-domain",
            "text": "insertAndSave(params) :  calls the dao.insert which does the bolier plate code you might find in a scaffolded controller. creates a new instance, sets the params and calls the dao.save (esentially the persist()).  ex:  Book.insertAndSave([name:'xyz',isbn:'123']) Throws a  DomainException  if anything goes wrong  update(params) :  calls the dao.update which does the bolier plate code you might find in a scaffolded controller. gets the instance base in the params.id, sets the params and calls the dao.save for it.  ex:  Book.update([id:11,name:'aaa']) Throws a (DomainException)[ https://github.com/9ci/grails-dao/blob/master/dao-plugin/src/groovy/grails/plugin/dao/DomainException.groovy ) if anything goes wrong   remove(params) :  calls the dao.delete gets the instance base in the params.id, calls the delete for it.  ex:  Book.remove([id:11]) Throws a  DomainException  if anything goes wrong   dao : a quick way to get to the dao for the Domain. It will return the stock dao that was created from GormDaoSupport or the Dao you created for the domain.",
            "title": "Statics added to the domain"
        },
        {
            "location": "/#daoutil-and-daomessage",
            "text": "See  DaoUtil",
            "title": "DaoUtil and DaoMessage"
        },
        {
            "location": "/#daoutil",
            "text": "checkFound(entity, Map params,String domainClassName)  checks does the entity exists, if not throws DomainNotFoundException with human readable error text  checkVersion(entity,ver)  checks the passed in version with the version on the entity (entity.version) make sure entity.version is not greater, throws DomainException  flush()  flushes the session  clear()  clears session cache  flushAndClear()  flushes the session and clears the session cache",
            "title": "DaoUtil:"
        },
        {
            "location": "/#daomessage-contains-bunch-of-help-methods-for-creating-text-messages",
            "text": "See  DaoMessage",
            "title": "DaoMessage contains bunch of help methods for creating text messages"
        },
        {
            "location": "/#grails-3",
            "text": "Dynamic methods were implemented with trait instead of meta programing, so now  @CompileStatic  can be used.\nDue to this changes static method  insert  for domain objects was renamed to  insertAndSave , because domain class instances\nalready have  insert  method and we can't have both static and instance methods with same list of args.  Example  To be able to use advantages of the dao plugin for REST apps, extend controller from RestDaoController:  See  RestDaoController  class OrgController extends RestDaoController Org  {\n    static responseFormats = [ json ]\n    static namespace =  api \n\n    OrgController() {\n        super(Org)\n    }\n}  If controller is extended for RestDaoController then methods will use dao services for current domain. For example\nPOST action will call dao insert method for Org domain.",
            "title": "Grails 3:"
        },
        {
            "location": "/id-generation/",
            "text": "Database ID Generator\n\n\nDao plugin comes with an implementation of hibernate identity generator which uses a central table for incremental identity generation.\n\n\nNewObjectId table\n\n\nIn order to use identity generator provided by plugin, you need to create NewObjectId table as shown below.\n\n\ncreate\n \ntable\n \nNewObjectId\n\n\n(\n\n    \nKeyName\n \nvarchar\n(\n255\n)\n \nnot\n \nnull\n \nprimary\n \nkey\n,\n\n    \nNextId\n \nbigint\n \nnot\n \nnull\n\n\n)\n\n\n;\n\n\n\n\n\nHere key name will be the name of the tables and NextId is the next id to return for the given table.\n\n\nConfigure Identity generator globally.\n\n\nThe identity generator can be configured globally in application.groovy as shown below.\n\n\ngrails\n \n{\n\n\n    \ngorm\n.\ndefault\n.\nmapping\n \n=\n \n{\n\n        \nid\n \ncolumn:\n \nid\n,\n \ngenerator:\ngorm.tools.idgen.SpringIdGenerator\n\n    \n}\n\n\n}\n\n\n\n\n\nThis will use the SpringIdGenerator for all domains in the application. However it can be done per domain too if required.\n\n\nUsing IdGenerator programmatically\n\n\nPlugin defines a bean with name idGenerator that can be used to programmatically generate new Ids.\nHere is an example domain class.\n\n\nclass\n \nBook\n \n{\n\n    \ntransient\n \nidGenerator\n\n\n    \ndef\n \nbeforeInsert\n()\n \n{\n\n        \nif\n(!\nid\n)\n \nid\n \n=\n \nidGenerator\n.\ngetNextId\n(\nBook.id\n)\n\n    \n}\n\n\n}\n\n\n\n\n\nIdentity generator will check in NewObjectId table for keyName \nBook\n If it exists, it will return the value of NextId or else it will insert a new row in NewObjectId table.",
            "title": "Id Generation"
        },
        {
            "location": "/id-generation/#database-id-generator",
            "text": "Dao plugin comes with an implementation of hibernate identity generator which uses a central table for incremental identity generation.",
            "title": "Database ID Generator"
        },
        {
            "location": "/id-generation/#newobjectid-table",
            "text": "In order to use identity generator provided by plugin, you need to create NewObjectId table as shown below.  create   table   NewObjectId  ( \n     KeyName   varchar ( 255 )   not   null   primary   key , \n     NextId   bigint   not   null  )  ;   Here key name will be the name of the tables and NextId is the next id to return for the given table.",
            "title": "NewObjectId table"
        },
        {
            "location": "/id-generation/#configure-identity-generator-globally",
            "text": "The identity generator can be configured globally in application.groovy as shown below.  grails   { \n\n     gorm . default . mapping   =   { \n         id   column:   id ,   generator: gorm.tools.idgen.SpringIdGenerator \n     }  }   This will use the SpringIdGenerator for all domains in the application. However it can be done per domain too if required.",
            "title": "Configure Identity generator globally."
        },
        {
            "location": "/id-generation/#using-idgenerator-programmatically",
            "text": "Plugin defines a bean with name idGenerator that can be used to programmatically generate new Ids.\nHere is an example domain class.  class   Book   { \n     transient   idGenerator \n\n     def   beforeInsert ()   { \n         if (! id )   id   =   idGenerator . getNextId ( Book.id ) \n     }  }   Identity generator will check in NewObjectId table for keyName  Book  If it exists, it will return the value of NextId or else it will insert a new row in NewObjectId table.",
            "title": "Using IdGenerator programmatically"
        }
    ]
}